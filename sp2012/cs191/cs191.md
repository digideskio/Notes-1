<a name='1'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Introduction -- January 17, 2012
--------------------------------

Course Information
-------

* Announcements on website
* Try Piazza for questions.
* GSIs:
  + Dylan Gorman
	- dgorman@berkeley.edu
  + Seung Woo Shin
	- lagnared@gmail.com
* Lecture notes on website. No textbook.
* Prerequisites: Math 54, Physics 7A/B, 7C or CS 70.
* Work and Grading:
  + Weekly homework
	- Out Tue, due following Mon @ 5 in dropbox (second-floor Soda).
  + 2 Midterms: 14 Feb, 22 Mar.
  + Final Project
  + In-class quizzes
  + Academic integrity policy

Today
-----

* What is quantum computation?
* What is this course?
* Double-slit experiment

What is Quantum Computation?
-------

* Computers based on quantum mechanics can solve certain problems
  exponentially faster than classical computers, e.g. factoring
  (Shor's algorithm).

* How to design quantum algorithms?
  + Requires different methodology than for classical algorithms
* Are there limits to what quantum computers can do? (Probably. Is not
  known to automatically solve NP-complete problems. Also, halting
  problem.)
* How to implement quantum computers in the laboratory (AQC, among
  other forms).
  + Can you design them so they're scalable?

Quantum computation starts with this realization that if we were to
base our computers on QM rather than classical physics, then they can
be exponentially more powerful.

This was really a big deal because it was believed that it didn't
really matter how you implemented computers; all that you could do was
make each step faster.

The fact that there's something like quantum computers that can be
exponentially faster, this was really a big surprise. And really on
fundamental problems, like factoring.

What this course will focus on is several questions on quantum computers.

Where we are for quantum computers is sort of where computers were
60-70 years ago.

* Size -- room full of equipment
* Reliability -- not very much so
* Limited applications

Ion traps.
------
Can trap a small handful of ions, small number of qubits. No
fundamental obstacle scaling to ~40 qubits over next two years.

Entanglement
------
Basic resource in quantum mechanics. Unique aspect of QM, and one
fundamental to quantum computing

Quantum Teleportation
------
Entanglement.

Quantum Cryptography
------
Ways to use QM to communicate securely (still safe even with Shor's).

This course
-----------

* Introduction to QM in the language of qubits and quantum gates.
* Emphasis on paradoxes, entanglement.
* Quantum algorithms.
* Quantum cryptography.
* Implementing qubits in the laboratory -- spin...

There are certain difficulties you can sweep away by focusing on it in
this language. It also highlights certain aspects of QM. Interesting
to focus on these aspects because they lend an alternative
interpretation of QM.

Aside:
------
There will not be programming projects. There will be a couple of
guest lectures. (not clear it will happen) would try to set things up
so we could go and play with equipment in lab. This obviously depends
on whether it scales and is set up well enough. Might be in place by
the end of the semester.

One thing that has to be done is arrange discussion sections. (under
discussion. Looks like a tentative Wed 11-12 and Fri 1-2.)

INTERIM.

Young's double-slit experiment.
----------
(particle-wave duality at quantum level. Physics completely
different. So different that it defies reason.)

There are two aspects of dealing with QM: understanding what those
rules are, and believing that nature works that way.

Hopefully you'll suspend your disbelief and just go with understanding
what the rules are.

(blah, more particle-wave duality)

(this basically boils down to interference.)

(tracking which slit each particle goes through leads to a collapse of
 the wavefunction, and we observe particles behaving like particles,
 not waves)

(talk about superposition of states; introduction of the wavefunction.
 Explained entirely by Schrödinger's cat.)

The thing that's most troubling about this from actual experience as
well as physics is that there has to be a mechanism. How did nature do
this? We are going to have a completely precise description. But it's
not going to be a mechanism unlike anything else.

Part of understanding QM is coming to terms psychologically with this
superposition of states, the existence in more than one state
simultaneously.

<a name='2'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Qubits, Superposition, & Measurement -- January 19, 2012
--------------------------------------------------------
Quantization:
-------------

 * Atomic orbitals: Electrons within an atom exist in quantized energy
   levels. Qualitatively -- resonating standing waves. (We have Bohr to
   thank for this)
   + The important thing is that there is this quantization, and you can
	 choose to think of the ground/excited state of an electron as encoding
	 in binary. Or you can have a k-level system, where you have energy
	 levels 0 through k-1. These are the things we'll be thinking about
	 notationally.
   + There are other systems we can think of as a two-level system,
	 e.g. photons (in terms of polarization, e.g.)
	 - spin (very roughly magnetic moment associated with the charge)
 * These are very rough descriptions. For our purpose, you can think about
   k-level systems, where you have k discrete levels.

Superposition
-------------
The first axiom of quantum mechanics is the superposition principle. It
says that if a system can exist in one of two states, then it can also
exist in a linear superposition of said states. Likewise, if it can exist
in k states, it can also exist in a superposition of all k states (trivial
to prove)

In other words, $\alpha_1\ket{0} + \alpha_1\ket{1} + ... +
\alpha_{k-1}\ket{k-1}$

Our $\alpha _i$ are actually probability amplitudes. These don't sum to
one; rather the magnitudes of their intensities sum to one.

(some talk about normalization in order to satisfy said property)

What does this superposition principle correspond to? We talked about the
double-slit experiment. Electron/photon going through one of two slits,
probability of which slit corresponds to these.

Measurement
-----------
The second axiom of quantum mechanics is the measurement axiom. The
superposition is the private world of this system. As long as you're not
looking at it, it's going to be in this linear superposition. But as soon
as you make a measurement, the outcome of the measurement is one of these
levels $\ket{j}$ with probability $\abs{\alpha _j}^2$ (i.e. you collapse
the wave function).

So if you go back to our last example, there we have a qubit (a quantum
bit) -- a two-level system is called a quantum bit because it's a quantum
analogue of a bit. So we had an example where we had a superposition of two
states. (demonstration of the probabilities)

[ talk about how attempting to detect which of the slits the particle went
  through actually constitutes a measurement, which changes the state of
  the system ]

  standard basis measurement:
	 checking exactly which state the system is in.

Another way of writing the state of a quantum system (as opposed to bra-ket
notation) is just saying that it's k complex numbers and presenting them as
a vector. Should be immediately intuitive. We still have the same condition
that the summation of $\alpha _i^2 = 1$. Our vector, therefore, must sit on
the unit k-sphere in k-space.

Ket notation: invented by Dirac. The reason we are going to be so enamored
by the ket notation is that it simultaneously expreses 1) the quantum state
is a vector in a vector space and 2) this quantum state encodes
information. The fact that we are labeling our states as $\ket{0}$ and
$\ket{1}$ is indicative in itself that we are encoding information.

Two ways of rephrasing the probability of landing in a particular state,
therefore is 1) the length of the projection onto said basis vector and 2)
$cos^2θ_j$.

Generalization of the notion of measurement: in general, when you do a
measurement, you don't need to pick the standard basis; you can pick any
orthonormal basis.

There is another useful basis called the sign basis: $\ket{+}$ and
$\ket{-}$. If placed on the unit circle, we have $\ket{+}$ located at
$\theta=\frac{\pi}{4}$ and $\ket{-}$ located at $\theta=-\frac{\pi}{4}$.

[ change of basis can be done using matrices or using substitution. ]

Significance of sign basis
--------------------------

The standard basis is going to correspond to a certain quantity. The sign
basis will correspond to a different quantity. By analogy, let's assume
that we're measuring the position or momentum of the system depending on
which basis we're using (might as well be -- Heisenberg's uncertainty
principle and all).

 explanation of Heisenberg's uncertainty principle, except without actually
  attributing a name to it. basically, with two related quantities, the
  more accurately you know one, the less accurately you can know the other.

 maximal uncertainty occurs with conjugate basis. measure of uncertainty:
  spread -- $\abs{\alpha_0} + \abs{\alpha_1}$. Corresponds to maximum
  uncertainty. Uncertainty ranges from 1 to $\sqrt{2}$.

Specifically, Heisenberg's uncertainty principle: $S(\alpha_0) + S(\beta_0)
\ge \sqrt{2}$. ($\alpha_0$, $\beta_0$ correspond to a conjugate basis)

<a name='3'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Multiple-qubit Systems -- January 24, 2012
------------------------------------------
Snafu with the projections, so lecture will be on the whiteboard! Will
also stop early, unfortunately.

State of a single qubit is a superposition of various states
($\cos\theta\ket{0} + \sin\theta\ket{1}$). measurement has effect of
collapsing the superposition.

(hydrogen atom: electron can be in ground state or excited state.)

Now we study two qubits!

TWO QUBITS
==========

Now you have two such particles, and we want to describe their joint state,
what that state looks like. Classically, this can be one of four states. So
quantumly, it is in a superposition of these four states. Our $\ket{\psi}$,
then, is $\alpha_{00}\ket{00} + \alpha_{01}\ket{01} + \alpha_{10}\ket{10} +
\alpha_{11}\ket{11}$.  Collapse of the wavefunction occurs in exactly the
same manner.

Probability first qubit is 0: $\abs{\alpha_{00}}^2 + \abs{\alpha_{01}}
^2$. New state is a renormalization of the remaining states.

ENTANGLEMENT
============
First, let me show you what it means for two qubits not to be
entangled. Essentially, we have conditional independence.

Quantum mechanics tells us that this is a very rare event (i.e. it
almost never happens).

Bell State
----------

You have two qubits in the state $\frac{1}{\sqrt{2}}\parens{\ket{00} +
\ket{11}}$. Impossible to factor (nontrivial tensor product), so we must
have some sort of dependence occurring. Neither of the two qubits has a
definite state. All you can say is that the two qubits together are in a
certain state.

Rotational invariants of Bell states -- maximally entangled in all
orthogonal bases.

<a name='4'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Entanglement, EPR, Bell's Experiment -- January 26, 2012
--------------------------------------------------------

Ignore Q4 on HW2. Probably.

Entanglement
============

Last time, we saw a Bell state (a Bell basis state). This is a state
of two particles (i.e. two qubits), and the state of each of the
qubits is "entangled", so to speak, with the other of the qubits.

This state has a very curious property, as we saw last time: maximally
entangled qubits will remain maximally entangled regardless of the
choice of bases, as long as they are orthogonal. This is known as the
ROTATIONAL INVARIANCE OF BELL STATES.

For the bell basis state α₀₀|00〉 + α₁₁|11〉, we have rotational
invariance for _real_ rotations only. Certain bell bases additionally
have rotational invariance over complex rotations.

FACT 1:

	You get the same outcome if measure both in the v, v⊥ basis.

FACT 2:

	Independent of separation between particles. It's not because
	the particles are close to each other and talking to each
	other; it's because of their state.

Einsten, Podolsky, & Rosen '35:

	Imagine that you have a pair of particles that are emitted
	(e.g. electron, positron) that are highly entangled. They are
	emitted in opposite directions and travel far from each other. And
	then you measure Particle 1 in bit (0/1) basis ⇒ knowledge of the
	bit on the other particle. Also, measure Particle 2 in the sign
	basis ⇒ knowledge of the sign on the first particle. Contradicts
	uncertainty principle?

	Not at all. { sign information destroyed, etc. } Sign information
	measured in the second particle has nothing to do with that of the
	first particle, since measuring the bit information destroyed the
	sign information (i.e. is now entirely unknown). { more questions
	regarding the Einstein/deterministic interpretation of quantum
	mechanics. }

Bell '64:

	Take two entangled particles. Despite large separation distance,
	they are quantumly connected. What you can do is start playing
	with the notion of measuring the particles in arbitrary
	bases.

	Make one measurement with outcome u. You'd have |v〉 and |v⊥〉
	with probabilities cos²θ and sin²θ.

	Bell's idea was this: Surely, if you play with your choice of u
	and v, you're going to get something good.

	We have some input, 0 or 1, that tells us which basis to
	pick. Suppose there are two experimentalists who have these
	entangled pairs of qubits. At the last minute, Alice gets as input
	some random bit; likewise, Bob gets some other random bit.

	We want to know the two output bits.

	Goal: maximize probability that r{a}r{b} = a + b (mod 2) = a ⊕ b

		If either of the inputs is a zero, they want to output the same
		bit. But if both of the inputs are one, they want to output
		opposite bits.

	Fact: If you choose the correct angles, in the quantum world, you
	get a success probability of cos²(π/8) ≈ 0.85.

	Claim: no way to do better than 3/4, if you agree to say the same
	thing in advance. (Local) hidden variable theory ≤ 0.75. Impossible
	to do better.

	However: Quantum mechanics gives us a success rate of ≈ 0.853, or
	cos²(π/8).

Alice's protocol is as follows: if r{a} = 0, measure in basis rotated
↻ π/16.  if r{a} = 1, measure in basis rotated ↺ 3π/16.

Bob protocol is as follows: if r{b} = 0, measure in basis rotated
↺ π/16.  if r{b} = 1, measure in basis rotated ↻ 3π/16.

{ where did these angles come from? If you plot them on the number
  line, you get four points a₁, b₀, a₀, b₁. When either is zero, we
  have a distance of π/8, else we have a distance of 3π/8. }

For the cases where (a ⊕ b), we have probability cos²(π/8). for the
case where !(a ⊕ b), we have probability sin²(3π/8) = cos²(π/8).

Conclusively disproves Einstein's hidden-variable theory.

There's this remarkable aspect where over time you can refine these
concepts to the point that we can sit down in an hour and a half to
understand these concepts that Einstein would have given anything to
understand. Isn't this remarkable?

When you actually do these experiments, they turn out to refute the
entire plan Einstein had.

<a name='5'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Gates -- January 31, 2012
---------------------------------

GATES, MORE GATES.

<a name='6'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Revisiting Axioms of Quantum Mechanics -- Feb 2, 2012
-----------------------------------------------------

We're going to be revisiting, over the next few lectures, the axioms
of quantum mechanics and how to refine them further.

Today: first axiom: superposition principle. In general, if we're in a
system that has k distinguishable states, then in general it is in a
linear superposition of these states. Each state is a unit vector, and
the states of the system reside on the surface of the sphere.

Addendum:
=========

What happens if we have two different subsystems? Take the first to be
k-dimensional, and the second to be l-dimensional. So now, in the
addendum, the question we are asking is "what happens if we take these
two subsystems and put them together and call this our new system?"
Take a tensor product of these two states. k × l distinguishable states.

So now, if you apply our superposition principle, what does it tell
us? We can be in any superposition of states. We are in a
superposition of basis vectors of (k ⊗ l).

Separately, we have k + l amount of storage space, but when we put
them together, we have k × l. These are the fundamental underpinnings
of quantum computing: this is where entanglement comes from; this is
where the exponential speedup comes from.

It's so very different from classical physics that if you chase it
out, you have consequences. One can just keep it at the level of
formalism, and then it's just notation; it's slightly weird. But then
you look at it and try to understand it, and it really has profound
consequences. So let's try to understand these consequences further.

[ calculating angles between states; inner product actually must be ]
[ equivalent to the product of the inner product of the components. ]

So now, let's back up for a moment and ask: we've said there's this
anomaly where we get a multiplicative effect instead of additive. Why?
They could be entangled. These states we are considering are product
states and are not entangled. In general, when you have a composite
system, you won't be able to decompose it into the tensor product of
two states, i.e. general state cannot be factored. For instance, Bell
states cannot be factored. You cannot say what the first particle must
be, and what the second state must be. All you can say is what the two
particles are simultaneously.

==== Intermission ====

Two different applications of concepts we've talked about before.

# No-cloning theorem

	Suppose you've got a qubit in the state |ψ〉, in some unknown
	state. Now that you have it, you'd like to make copies of it. What
	you have in your lab is lots and lots of qubits which you can
	initialize to the state |0〉. We also have a lot of fancy
	equipment. You think to yourself, surely, given the fact that I
	have all this fancy equipment and all these post-docs running
	around, we should be able to make at least one copy of this
	quantum state.

	So we want at least to have the state |Ψ〉 ⊗ |Ψ〉. We want to
	start with |Ψ〉 ⊗ 0 and go to |Ψ〉 ⊗ |Ψ〉 using fancy
	equipment. We can do plenty of unitary transformations (third
	axiom of quantum mechanics: no matter how big your lab is, it's
	only going to perform a unitary transformation). Is this possible?
	No-cloning theorem says this is impossible.

	There's a principle called the Church of the Larger Hilbert
	space. If you really want to, you could expand your Hilbert space,
	and consider measurements to be something that happens in this
	larger Hilbert space, and you're only looking at part of your
	data. In this larger Hilbert space, this is unitary in the larger
	Hilbert space.

	Right now we're considering a closed system. Later we can make
	this theorem more general and include everything, but the
	statement will remain the same.

	All you can do is perform some rotation on your Hilbert
	space. However, we must preserve angles. Such a unitary
	transformation only exists if we know that |Ψ〉 is one of two
	known orthogonal states.

	Basically, this tells us that we cannot clone an unknown quantum
	state. There is only one exception: when you know that it is one
	of two known orthogonal states.

Quantum Teleportation
=====================

	Related is the concept of quantum teleportation. Quantum
	teleportation provides a way to transfer a particle from one party
	to another, if the two parties share an EPR state (Bell state).

	Quantum teleportation is this protocol by which the first party
	performs a joint measurement on two qubits. The result of this
	measurement is one of four results, which is shared with the
	second party. The second party then performs one of four
	operations (a series of quantum gates) on the other qubit and
	receives as a result of these operations the original quantum
	state.

	There's this property of entanglement called monogamy. A qubit
	cannot be maximally entangled with multiple qubits.

These things took a while to figure out. At first, it was completely
unclear. When this was happening in the early 90s, we'd spend a lot of
time figuring these things out. It was not easy. We'll need some more
concepts, though.

<a name='7'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Observables, Schrodinger's equation -- Feb 7, 2012
---------------------------------------------------

Observable
==========

Operator (i.e. can be described by a matrix) that describes any quantity
that can be measured, like energy, position, or spin. You feed in a quantum
state and receive as output a real number.

Why an operator? If you have a k-level system, then an observable for this
would be a k-by-k Hermitian matrix (i.e. $A = A^\dagger$). Important thing
about hermitian matrices: spectral theorem: orthonormal eigenbasis of
eigenvectors $\phi$ that correspond to real eigenvalues $\lambda$.

The real number you get as a result of the measurement -- what you read out
in the measurement outcome -- is $\lambda$. Consider discrete energy
levels; after a measurement, we collapse the wave function into a single
eigenstate.

We already knew what a measurement was. So what happened here, how can we
have a new definition of a measurement? This isn't fair. How can you trust
a course that changes its mind every other week? No complaints? I mean,
isn't it terrible? This is completely different. So what's going on?

Our previous notion of measurement required us to choose some orthonormal
basis. We write out our state $\Psi$ in this basis. The result of the
measurement was equal to i with probability $\abs{\beta i}^2$, and the new
state was $\ket{\Psi_i}$. So how does this correspond to what we have now?

We can reconcile them by showing that our old notion was less
formalized. It's only that basis which corresponds to the basis vectors of
some Hermitian matrix.

Pick any arbitrary orthonormal set of vectors and an arbitrary set of real
numbers. Ask: is there any matrix that has these eigenvectors and these
eigenvalues? Argue: always possible. In that sense, the new definition of a
measurement is really the same as the old one.

Consider case where eigenvalues not unique: reconsider notion of orthonormal
eigenvectors as notion of orthonormal eigenspaces. We've seen an example of
this, by the way: when we had a two-qubit system and we only measured the
first qubit. Each of the two outcomes corresponded to a two-dimensional
subspace. There were two eigenvectors with the same eigenvalue. Project the
subspace onto the space spanned by eigenstates corresponding to result of
measurement.

Reasoning: in the general case, you don't project onto a basis vector; you
project onto the subspace that is consistent with the outcome of the
measurement.

What the measurement does is provide some information about the state and
change the state to reflect the outcome. It doesn't restrict itself any
more than it has to.

diagonalization: converting to a different basis, scaling appropriately,
converting back to the original basis.

A way to construct the operator (must be a hermitian matrix) is with an
outer product: you can generate the change-of-basis matrix.

==== Intermission =====

Piazza: posted question about other people wanting midterm moved. Enough
objections such that we will stick with original date: next Tuesday. Posted
yesterday a homework which is effectively a review for the midterm, which
will cover everything up until this lecture. Three problems on homework: 2
are review, 1 is on today's lecture. **Due this Friday at 5.**

Schrodinger's Equation
======================

Most basic equation in quantum mechanics; describes how a system evolves
over time. Depends on one particular operator, the Hamiltonian: the energy
operator (more specifically, kinetic energy T + potential V). When you
write out the Hamiltonian of this system, the eigenvectors correspond to
(eigen)states with definite energy. The corresponding eigenvalue $E_i$ is
the corresponding energy.

So now what Schrodinger's equation says is that the state \psi of the
system is a function of t, and it evolves according to a differential
equation which relates the energy of the system.

$i\hbar \pderiv{\psi}{t} = \hat{H} \psi$
($\hbar \equiv $Planck's constant, $i \equiv \sqrt{-1}$)

The rate of change depends on what the Hamiltonian tells us to do. You can
consider the Hamiltonian talking about interaction between parts of the
system or between subsystems. Forces. Everything.

Now, Schrodinger actually discovered this equation in 1926. This was after
many of the initial discoveries in quantum mechanics. It was after
deBroglie discovered the wave-particle duality. One of the biggest
intellectual events of the twentieth century.

So let's see what this equation tells us about the equations of motion. PDE
solving, yay.

So what we know is that if the state at time 0 was an eigenvector $\phi$,
then the state at time t must be some constant $A(t)\phi$.

precession of individual states; generalization is the summation of the
various eigenstates. If you want to write out the linear operator that
tells you how to go from $\Psi(x,0)$ to $\Psi(x,t)$, it's just the diagonal
matrix of eigenvalues. You can check that this is a unitary matrix.

The way you write this unitary matrix in notation is $\exp(-i\lambda
t/\hbar)$. Nothing to be scared by. Look, we're exponentiating a matrix,
but that's nothing to be worried about.

Suppose $\psi(0)$ = $\ket{0}$, and you wanted to know $\psi(t)$.

<a name='8'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Schrödinger's Equation -- Feb 9, 2012
-------------------------------------

Had the sense last time that some of you might not remember all of your
linear algebra. So this time is a hybrid of linear algebra and getting you
up to speed with this bra-ket notation.

What we are going to be doing is looking at it from three or four different
viewpoints to try to get an intuition for why it is the way it is. So when
we get around to trying to solve the SE for specific equations, it's not
just an equation; you have a feel for it.

Goal for today: Figure out why does the Hamiltonian plays a role in
Schrödinger's equation.

So basically, the way we are going about this is that last time, we had a
rather abstract formulation of Schrödinger's equation. Why? It's because
the formulation is so clean. General form: write out hamiltonian,
diagonalize it, and once you understand the eigenvalues and eigenvectors,
you understand why it has the form it does.

So why does it look the way it does? Conservation laws.

Next week, we'll look at it for concrete systems; for continuous systems;
the behavior of an unstrained particle. In each of these cases, we're
trying to build an intuition as to _why_ the Schrödinger equation is the
way it is.

Not going to get into time-dependent hamiltonians until maybe the end of
the semester.

Do Hamiltonians correspond to quantum circuits? The way you implement gates
is by implementing a suitable Hamiltonian. But a quantum circuit
corresponds to a time-varying Hamiltonian. Topics we'll get to closer to
the end of the semester.

What we are starting with are the basics of quantum mechanics. Viewing it
in the case of discrete systems, i.e. qubits. We've already started with
quantum gates, quantum circuits.

We're going back and forth between this abstract version which is very
close to axiomatic quantum theory (but also helps with the understanding of
theory), and physical systems (hamiltonians). After a few weeks of physical
systems, we'll start talking about quantum algorithms.

And then, after we have developed that for a little while, how do you
implement all this in a lab? We'll go back and look at the physics of it.

We're sort of walking this fine line between thinking about quantum devices
as abstract entities; where all you need to know is the axioms of quantum
mechanics; thinking about what you can and cannot do, and what you have to
do to make it all happen.

So let's start with the basics. What I'll do today is I'll describe in a
little more detail Dirac's bra-ket notation. We've already seen this
notation to some extent, but let's do this more systematically.

Remember if you have a k-state quantum system, then its state is described
by a unit vector in a k-dimensional Hilbert space. This is also
equivalently described in ket notation as α{j}|j〉. We love this notation
because it simultaneously highlights two aspects: this is a vector, and it
is information. For example, if k=2, this is a qubit storing a bit of
information.

The dual space (row space) of this, if you write this state as |Ψ〉, is the
bra 〈ψ| (hermitian conjugate). The inner product (square of the length of
the vector) is simply 〈Φ|Ψ〉

People who love the bra-ket notation love it because you don't have to
think. You just do what seems right and everything magically works out.

So if you have a vector |Ψ〉, you can talk about the projection operator
projecting onto |Ψ〉. It's a linear operator. What you want to do is design
the projection operator onto Ψ (often denoted by P) ≡ |Ψ〉〈Ψ|.

Pⁿ should ≡ P, for obvious reasons. |Ψ〉〈Ψ|Ψ〉〈Ψ|: 〈Ψ|Ψ〉 = 1, so
multiple applications of an operator are equivalent to a single
application.

Suppose |Ψ〉=|0〉. What does P look like as a matrix?
[1...0]
[..  0]
[. . 0]
[0  .0]

I = ∑|j〉, therefore. It doesn't have to be in terms of the standard
basis. You could write down the identity in terms of any basis in this
way. Physics refers to this as the "resolution of the identity".

Example
-------

Suppose you have a vector and you want to measure it in a general basis.

What happens if we measure |Ψ〉 in the |v〉, |v^{⊥}〉 basis? Do a change of
basis on |Ψ〉. Project |Ψ〉 onto each of the basis vectors. This is one way
of doing it.

==== Intermission ====

Goals for the midterm: fluency with the basics. Purpose of the course: not
a sequence of tests as much as getting something out of it. But to get
something out of it, you should be fluent in the maneuvers presented so
far. Not enough that you can sit down and figure it out in ten minutes.

Midterm will not be open-book or open-notes, but anything that you'd need
to remember will be on the midterm itself. e.g. teleportation protocol
would be given.

Observables
===========

An observable is a Hermitian matrix M such that M = M†. So now we have
something called the spectral theorem, which says that hermitian matrices
can be diagonalized: you can write them in a different basis (the
eigenbasis), and you can write them out in this eigenbasis.

Suppose M = X (bit-flip). Xv = λv. (X-λI)v = 0. det(X-λI) = 0. Solve for λ,
which are your eigenvalues, and then we go back and solve for our
eigenvectors.

Here, we're going to do this by inspection. Eigenvectors of X would be
$\ket{+}, \ket{-}$; the corresponding eigenvalues are 1, -1.

Why is this an observable? If you were to create the right detector, we'd
observe something. We'd measure something. What we read out on the meter is
$\lambda\ket{j}$ with probability equal to $\alpha_j^2$, and the new state
is $\ket{\Psi_j}$. What Schrödinger's equation tells us is that if you look
at the energy operator H, and then in order to solve this differential
equation, we need to look at it in its eigenbasis. It was not supposed to
be so frightening. You can write U(t) notationally as $e^{-iHt/ℏ}$.

Why H?
------
Why should Schrödinger's equation involve the Hamiltonian? Why the energy
operator? What's so special about energy? Here's the reasoning: from axiom
3 of quantum mechanics, which says unitary evolution, what we showed was
the unitary transformation is $e^{-iHt/\hbar}$. Any unitary transformation
can be written in this form. You can always write it in the form $e^{iM}$
for some Hermitian matrix M. The only question is, what should M be? Why
should M be the energy function? The second thing that turns out (either
something that we'll go through in class or have as an assignment) –
suppose that M is a driving force of Schrödinger's equation. So
$\pderiv{\Psi}{t} = M\ket{\Psi}$.

Suppose there were some observable quantity A that is conserved: i.e. if
you start out with a measurement of |Ψ(0)〉, and you do the same
measurement at time t, if A is a conserved value, then this expected value
should be the same both times. If A is conserved, then AM = MA. A has to
commute with M. This tells us that their eigenvectors are the same. The
fact that energy is conserved, therefore, says that HM = MH. Then we have
one last bit: energy is very special. It is very fundamental; these are the
building blocks; it goes right to the core. H commutes with M not for
special conditions of the system, but rather generally.

So you can reason that M is a function of H. And then you show that it must
be a linear function of H (aH + b), b must be 0, and a must be a constant
(in fact, Planck's constant).

Symmetry plays a very strong role in the way this comes about.

<a name='9'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Continuous Quantum States, Free particle in 1D, Heisenberg Relation
--------------------------------------
Feb 14, 2012
------------

So far we've talked about discrete quantum systems. Today, we're going to
make the transition to talking about continunous quantum systems. In 1
dimension, the particle can be anywhere on the line.

Schrödinger's equation in 1 dimension, Heisenberg relation.

iℏ(∂Ψ(x,t)/∂t) = [-(ℏ²/2m)(∂²/∂x² + V(x)] Ψ(x,t) = HΨ(x,t)

Some things where won't be terribly careful about being precise for
now. Will fix later to extent that you won't be too upset about it
later. Attempt to day is to try to understand these objects on an intuitive
level. Before we do that, let's do a five-minute review of discrete
systems, just to orient ourselves when we go to continuous distributions.

Back to the familiar k-state systems. State is a unit vector in k-dim
Hilbert space, etc. And then we have this notion of an observable (given by
a Hermitian matrix M ≡ M†). What we like about this is that by the spectral
theorem, we have an orthonormal basis of eigenvectors corresponding to real
eigenvalues. Result is that discrete energy levels correspond to orthogonal
vector spaces.

Since this is an observable, the deflection of our meter is λj with
probability |〈Ψ|Φj〉|², and the new state is |Φj〉. We could ask a
couple of questions.

Before we continue: let's look at another way of considering M being
Hermitian: Mij = 〈Φi|M|Φj〉 = conj(〈Φj|M|Φi〉) for any Φi, Φj; not
necessarily just for basis vectors.

	* We can try to picture the measurement outcome. What our measurement
	  looks like is this: some probability distribution. We can
	  characterize this distribution by its moments, much like how we can
	  characterize a function by its derivatives. The more moments we have,
	  the more we know about our distribution.
		+ mean: location.
		+ standard deviation: width.
		+ skewness: symmetry.
		+ kurtosis: peakedness.
	* We can consider the mean to be 〈Ψ|M|Ψ〉.
		+ First write M in its eigenbasis, where it's a diagonal matrix.
	* We can also do the same for variance. Var(X) = E(X²) - E(x)² = E(X²)
	  - μ², for obvious reasons. E(X²) = 〈Ψ|M²|Ψ〉: intuitive after
	  considering that M² preserves eigenvectors while squaring eigenvalues
	  (result of diagonalizability of M).

Here's what we're planning to do (hopefully) for the rest of the lecture:
it'll be in the form of a sketch, which hopefully will give you a picture
of what happens when you look at a particle in 1 dimension.

Before that: σ (standard deviation) is a measure of spread. If you were
really certain about a physical quantity, you'd have σ ≡ 0.

So, let's have a particle that's free to move about in one dimension. We'll
describe approximately for now; we just want to understand its form. Later
will be much precise, but now we just want to put an image in our minds as
to just where this equation comes from. We'll want to understand position
of the particle x (how it behaves) as well as momentum p. We'll also look
at the uncertainty relation that says ΔxΔp ≥ ℏ/2 (some constant). Show
intuitively that there must be some minimum.

In this continuous picture, x and p behave like something you've already
seen: bit and sign. There's something about the spread of the two. You
cannot know both of those quantities precisely, either in the one, or the
other, or both. The more certainly in one, the less certainly in the
other. Rather than do it by formula and precisely, we'll do it more
intuitively.

Often, when you think you want to explain something so that people really
understand, you want to go slowly. Paradoxically, it's sometimes better to
go fast. Explanation: it's easier to put all the pieces together when you
see the big picture all at once. See big picture first, then observe
individual bits later.

We want to talk about a lot of stuff.

Once again, what we are trying to do is describe the state of the particle
on an infinite line. So now, before you describe it, let's do an
approximation. Let's consider this as not infinite, but very long (take a
limit). Likewise, not continuous but very fine (also a limit). Could be at
one of various positions. Describe your state as this superposition of
states. What we're saying is that Ψ(j) is αj. When we generalize this to a
particle being anywhere on the line, the way to describe it is Ψ being a
continuous function, so Ψ(x) is a complex-valued function on the real
line. As in the discrete case, we want our distribution to be normalized.

Now, suppose we wanted to measure the position of this particle. Out here,
we'd have an observable, M. The corresponding observable in the continuous
case, let's call it x. We'd just do 〈Ψ|x|Ψ〉. Our inner product now is
defined with integrals.

Our observable now takes as input a wave function Ψ and spits out another
function as output.

More fuel for intuition: you should know one of the big discoveries: nature
is described by local differential equations. Every point in space only
considers its own neighborhood. It's concerned only with itself, and
nothing else. So now let's apply that principle here. How that wave
function evolves over time. So the point x is minding its own business and
its own infinitesimal neighborhood. So what does it do? The simplest thing
it does is compare itself to its neighbors, say the average of its
neighbors. (consider perceptron, maybe?) But this yields the second
derivative with respect to x, and the function smooths itself out. So we
must move in an orthogonal direction to avoid collapsing the wave
function, i.e. multiply by i.

Let's now try to understand where the uncertainty principle comes in.

Momentum we can measure in the quantum case; it's sort of a proxy for
velocity, since velocity doesn't really make sense.

Let's consider a fairly standard wave exp(i(kx-omegat)). Now you ask what the
equation of motion says if it's going to evolve. Let's say Ψ(x,0) ≡
exp(ikx). omega is the rate at which it twists over time. A twisting seems to
correspond to some sort of translation. The rate of translation is directly
proportional to k.

So now we have a function of definite momentum. We can then decompose this
wave function in terms of these functions. These are our Fourier basis
functions. So if you want to go from the position basis to the momentum
basis, you take a Fourier transform. In other words, this is roughly
equivalent to what we do when we go from the sign basis to the bit basis,
or vice versa (what a Hadamard gate does).

<a name='10'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Free particles, Uncertainty, Quantization
-----------------------------------------
Feb 21, 2012
------------

We talked about things informally last time, and what we were going to do
was see Schrödinger's equation from various viewpoints.

Today, again we'll look at a free particle in one dimension, a somewhat
more rigorous of the uncertainty relation, quantization, and use that as
our first implementation of a qubit.

What we want to do is describe how this state evolves in time. This is what
was described by Schrödinger's equation. Last time, we derived what this
equation should look like (approximately) as a result of certain
considerations.

Clasically, the energy of this particle (which we'll write as a function of
two parameters p and x). ∂ψ/∂t = p²/2m + V(x).

So, first of all, we want to figure out what corresponds to the position in
quantum mechanics? How do you measure the position of this particle? We
said we had a position operator, and when you applied it to ψ(x), what you
got back was xψ(x). Same idea of measurables as before: we're measuring
position, so our eigenvalues correspond to the position of the
particle. What we are requiring from our position operator is exactly the
same thing.

So the momentum operator \hat{p} is ℏ/i (∂/∂x). ℏ is our normalized
Planck's constant. Again, the discrete analogue of this is a
measurable. Once again, we're ignoring constants, since we only really care
about constants.

What the correspondence principle says is that what you should do (when you
know what the classical situation looks like) is to just substitute \hat{x}
and \hat{p} instead of x and p, and put that down for your energy
operator. So why do you do this? Better people than us have done this in
the past, and it seemed to work out for them.

So clearly, what Schrödinger's equation must say is:
iℏ ∂ψ/∂t = -ℏ²/2m ∂²ψ/∂x².

(ignoring potential energy as a result of it being a free particle – not
subject to any potential / potential is equivalent to 0.)

Uncertainty
===========
Let's just try to see how our function (given as a function of x) looks as
<a function of p. What we said last time was that was the Fourier
transform. Fourier basis and standard basis are "like oil and water" – if
one is maximally certain, then the other is maximally uncertain. So you
cannot come up with any wave function that is localized in both spaces. So
we can try to quantify this. We had nice pictures, but now we're going to
work directly with operators. It's going to not vague and very precise, so
for some, it'll be great. But for others, it'll be a disaster since there
are no pictures.

Remember: the thing about an observable that we care about most is the
eigenvector decomposition. So the question is: what do the eigenvectors
look like? That determines how nicely they play with each other.

Discrete case first. Remember you had your phase-flip operator Z, bit-flip
X. Considering the eigenvectors and eigenvalues, the claim is that this is
as good as you are going to get.

Another way to measure how different these eigenvectors are is to see
whether these matrices commute or not. If they commute, they have a common
set of eigenvectors. Commuting means XZ - ZX = 0. So we want to look at XZ
- ZX (a commutator, denoted by [X,Z]).

So what does this look like between \hat{x} and \hat{p}? We have product
rule coming into play... yielding [x,p] ≡ iℏ.

We'll use this to derive ΔxΔp = ℏ/2. We'll do this quickly so we'll have
time to talk about the particle in a box.

Recall: given an observable A and a state |Ψ〉, the expected value is
〈Ψ|A|Ψ〉. We also saw that the variance was E(x²) - E(x)², so in this case
σ² = 〈Ψ|A²|Ψ〉 - 〈Ψ|A|Ψ〉². 

For now, assume 〈Ψ|A|Ψ〉 = 0. Makes derivation simpler, and we're just
asserting that we don't really lose much (anything, really).

Take Ψ ≡ A|ψ〉, Φ ≡ B|Ψ〉. By Cauchy-Schwarz, we have that this is greater
than or equal to 〈Ψ|Φ〉 = 〈ψ|AB|ψ〉. By symmetry, it's also greater than
or equal to 〈Φ|Ψ〉 = 〈ψ|BA|ψ〉. As a result, (ΔA)²(ΔB)² ≥
|〈ψ|AB-BA|ψ〉/2|² = |〈ψ|[A,B]|ψ〉/2|² = |〈ψ|iℏ|ψ〉/2|² = ℏ²/4. So the
square of the spread of x + square of spread of momentum is at least
ℏ²/4. If you take square roots, you get the proper result. (you can get a
better bound by being more careful by also using the anticommutator. We
were being sloppy for the purpose of making things simpler.)

Particle in a box
=================

This is basically just the infinite square well. We want to figure out our
eigenfunctions just by looking at the operator. Again the way we do this is
guess and come up with the right answer by chance. You expect the
eigenfunction to be an exponential, so we guess and check. Life is nice
that way.

We are trying to solve for H|φ〉 + E|φ〉. Guess that |φ〉 = e^{ikx}. Let's
figure this out. Our maneuver is to say that we're dealing with a separable
equation ("decompose this problem" by looking at the eigenvectors of H).

Suppose our state was one of these eigenvectors. We then know what the
Hamiltonian does to it: it simply applies a scalar (the corresponding
energy level). So of course we want to write our function in this basis,
since we know how to solve the simpler differential equation.

The operator affects each eigenvector separately. So we can tack on the
time dependence as an afterthought (to each eigenvector).

COMING UP
=========

We'll solve this problem using this very strategy. We know what the
eventual answer looks like: ∑e^{-iEt/ℏ}|ψ(x)〉

<a name='11'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantization, Particle in a box, Implementing Qubits
----------------------------------------------------
Feb 23, 2012
------------

A more precise review
=====================
By this point, we've talked about a number of things. Discrete/continuous
quantum systems, measurements, and so forth. So what I'd like to do for the
first half of the lecture is give you a slightly more formal overview of
everything we've talked about before: about the model. In some sense what
we've been talking about has been challenging, but in some sense it's also
rather simple (i.e. we can do a more precise, more formal review of what
we've covered quickly).

Multiple-qubit systems
----------------------
So let's start from the beginning. If our state is a discrete system, $\psi$
is an element of a $k$-dimensional vector space.

The second thing we want to say about quantum states is the following: what
happens if you have two quantum systems, $a$, a $k$-level system, and $b$,
an $l$-level system? Now we want to understand what happens when we put $a$
and $b$ together and look at them as a composite system? When you put states
together, you need to take tensor products. If we happen to be in the state
$|i\rangle$ in one system and $|j\rangle$ in the other system, then
corresponding to that we have a state in the composite system as $|i\rangle
\otimes |j\rangle$, which can be written as $|ij\rangle$, if you're being
especially lazy.

The number of dimensions we get is $kl$, which is the dimensionality of the
space in which the composite system lives.

This is called taking tensor products.

The new system inherits the properties of the old one; for instance, how do
you compute inner products? Suppose a-system happened to be in the state
$|00\rangle$, and another was in $|++\rangle$. What is the angle between
these states? If you were computing the inner product, $\langle 00|11
\rangle$, then you would just take the inner products of the pieces
separately.

What is more interesting to us is measuring the probability of a state, and
that corresponds to its magnitude.

Evolution of states
-------------------
We had our Hilbert space, and our evolution was just the rotation of our
Hilbert space. This was a rigid body rotation in that it preserved
angles / distances. So the inner product is not going to change as you do
this rotation.

And then we had our favorite gates, which consisted of things like the
bit-flip (X), phase-flip (Z), Hadamard (H), controlled not (CNOT, a
two-qubit gate).

So now, here's what I wanted to get to. Suppose you have two qubits, and
you apply a gate on each of them. Now you want to understand what operation
was applied. So first we must understand the form of the answer: it will be
a 4x4 matrix. And then to understand how to write out this 4x4 matrix:
effectively, we take the tensor product of the indivdual gate matrices.

$$A \otimes B = \begin{pmatrix}
a_{00}B & a_{01}B \\ a_{10}B & a_{11}B
\end{pmatrix}
$$

Observables
-----------
So then you have measurements, and we said that measurements correspond to
an observable M, which is a Hermitian operator, i.e. $M_{ij} = M_{ji}^{*}$.

So now, why is an observable M? Because we said when you have a Hermitian
matrix, by the spectral theorem, you have an orthonormal eigenbasis that
correspond to real eigenvalues. What you get as the outcome of a
measurement is some $\lambda_j$. This occurs with probability equal to
the square of the length of the projection onto the eigenspace
corresponding to $\lambda_j$. The new state is $|j\rangle$.

There is a special observable known as the Hamiltonian $\hat{H}$, the
energy observable. In order to solve the Schrodinger equation, which looks
very complex, if you write it in terms of the eigenvectors, we can neatly
partition it into a number of simpler differential equations, one for each
eigenvector. Since these are eigenvectors, the evolution of the system
leaves the direction alone, and all it does is change the amplitude and the
phase. There is a very nice short-hand for writing this: $e^{-i\hat{H}t}$:
this is our evolution operator, and you can check that it is unitary.

Continuous quantum states
-------------------------
So now let's fill in the corresponding picture for continuous quantum
states.

No longer finite, and it's even continuous. So, like a particle on a line,
and now you have a probability distribution representing your amplitude
(sort of; more like intensity). Usually you talk about what the probability
is of being in some range (of being in the neighborhood of x). If you were
looking at x itself, the amplitude would be zero (excepting Dirac
deltas). So now $\Psi$ is a function mapping $\mathbb{R}$ to
$\mathbb{C}$. It's normalized such that $\int |\Psi|^2dx = 1$. Another way
of saying this is that the inner product of $\Psi$ with itself,
$\langle\Psi|\Psi\rangle$, is 1.

So what's the corresponding vector space we have for a continuous vector
space? We need some set of eigenfunctions that span all complex
numbers.

Then we have this notion of observables in these continuous systems, which
is going to be just like it was in the discrete case. So what does it do?
It takes a state $|\Psi\rangle$ and maps it to $M|\Psi\rangle$. So we'll
just have some operator that maps a wave function to a not necessarily
normalized wave function.

And so we have two examples that we saw: $\hat{x}$, the position
observable, which maps $\Psi(x)$ to $x\Psi(x)$, and then we had $\hat{p}$,
the momentum observable, which maps $\Psi(x)$ to $i\pderiv{\Psi(x)}{x}$.

So we need these to have some notion of Hermitian. We must have
$\langle\phi|M|\psi\rangle = \bar{\langle\psi|M|\phi\rangle}$. We call this
sort of operator "self-adjoint".

Remember: integration by parts.

The momentum matrix would be skew-Hermitian ($M^\dagger = -M$), so we had to
multiply by a factor of i.

On this particular homework, all you have to do is work your way through
things like this (whether certain operators are Hermitian or not) and
compute the commutators of certain matrices. Should be an easy or useful
exercise, depending on how used to this sort of thing you are.

So now, let's talk about a particle in a box. We assume there is a box of
length L with infinitely high walls (i.e. infinite square well). Basically,
consider behind the boundaries of these walls there is a potential so large
that the particle cannot afford to leave.

So we want to solve Schrodinger's equation. What are the states? $H =
\frac{\hat{p}^2}{2m} \Psi = \frac{-\hbar^2}{2m}\pderiv{^2}{x^2}
\psi$. Rather than carry this potential around with us, we'll just impose
boundary conditions. $\Psi(0) = \Psi(l) = 0$. So this is H. Remember how we
solved Schrodinger's equation; we solved the eigenvalue problem. We tried
to figure out the eigenvalues $\phi_j$ and the corresponding energies
$E_j$.

So now we want to understand what these eigenvalues look like for
corresponding energies. So what's an eigenfunction of this? The guess (what
we want) is for the eigenfunctions to look like e^{ikx}. Just evaluating
the right-hand-side, we get $E_k = \frac{\hbar^2 k^2}{2m}$. This is both
the energy of $e^{ikx}$ as well as $e^{-ikx}$. So we guessed what the
eigenfunction looked like, and then we checked.

So we checked that $\psi_E(x)$ is going to be of the form $Ae^{ikx} +
Be^{ikx}x$. When you take linear combinations of the two exponentials listed
above, you might as well take linear combinations of $\cos(kx)$,
$\sin(kx)$. This form is nicer because it is easier to impose the boundary
conditions. Enforcing boundary conditions, we get that $C = 0$ (which makes
sense; cosine is even, and this function is 0 at x=0) and that $D =
\frac{k\pi}{l}$.

We now want to find C, which we can get by enforcing that our wave function
is normalized. use the $\int (sin^2 + cos^2) = 2\int (sin^2)$ trick.

Finally, let's just go back and make two nice observations. Now you finally
see how to implement a qubit. To implement a qubit, you would restrict the
energy to be small enough to be in the first two modes. And then you would
let zero be one qubit and one be the other.

<a name='12'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Algorithms
==================
Feb 28, 2012
------------
Introduction
============
Today we're going to make a transition to quantum algorithms. But first, a
brief review of particle-in-a-box.

Particle in a Box
=================
The particle in a box is sort of a toy model for a hydrogen atom. In what
sense? In a hydrogen atom, you have a proton and an electron, and the main
force it is subject to is Coulomb attraction. So for our purposes, as a
very first, very simple model, we'll think of writing out Schr\"odinger's
equation in the radial direction.

We'll think of this electron as not three-dimensional, but
one-dimensional (radial). And instead of dealing with the potential as it
is, we'll approximate it by saying what the potential really does is
confine the electron to within some range $\ell$. What we're going to do is
model the situation by saying that the electron is a free particle in a
box.

* Aside

	It's worth thinking about this: once we solve this, we get a first
  picture what a hydrogen atom looks like. When we plot out the solution,
  what does this tell us about an electron and where it sits? This gives us
  a first approximation; really inexact. But for our purposes, since we are
  not so much wanting an understanding of the hydrogen atom so much as
  wanting a general understanding, this is a great model.

Normally we consider this particle as free to move anywhere, but now we
impose an infinite potential outside of a particular region. Writing out
Schr\"odinger's equation where $H \equiv \frac{-\hbar^2}{2m}
\pderiv{^2}{x^2}$. We initially did this by guessing that the eigenvectors
were of the form $e^{ikx}$. We guessed this, figured out that the
eigenvalues (energies) corresponding to this must be $\frac{\hbar^2 k^2}
{2m}$, and then we said look, what this means is that $e^{ikx}$ and
$e^{-ikx}$ have the same energy, so we might as well just use the sinusoids
$\cos(kx)$ and $\sin(kx)$. We solve for coefficients by imposing the
boundary conditions.

We also went ahead and normalized our wave function by saying $\int_0^\ell
\abs{\psi_n(x)}^2dx = 1$. What this further gives us is that $D =
\sqrt{\frac{2}{\ell}}$. So our general solution is $\psi_n(x) = \sqrt{\frac{2}
{\ell}}\sin\frac{n\pi x}{\ell}$. This tells us about the quantization of
energies. The fact that it takes on these discrete values means that you
get these standing waves of definite energy.

There's also a way of making this analogy a little more quantitative. We
can attempt to go ahead and do that. If we look at $E_2 - E_1$ (the energy
difference between the first excited state and the ground state), for our
model, we got $\frac{3\hbar^2 \pi^2}{2m\ell^2}$. Assume $\Delta E \approx
10$ eV; let's find out what $\ell$ is (compared to $\ell_H \approx 1
\AA$, the actual value). We could substitute and solve, and we get roughly
$3.4 \AA$. As long as you make sure your energy is small, what you know is
that your particle is always in some superposition of the $n=1$ and $n=2$
states.

Precession of phase
-------------------
Remember that you are in always in some superposition of states, which
evolves over time. So I hope you can see what your qubit is, now. The
associated value of a qubit corresponds to a particular superposition. If
you do an inner product between any two of these superpositions, you get
complete cancellation.

We get a changing phase, yes, but this is no big deal; we can simply
account for a moving reference frame.

Because we have this phase precession, if you look at what the frequency
corresponds to, it's whatever the frequency of visible light is, let's
say. The fact you have this precession at this frequency allows you to
control this qubit from the outside using light (lasers). So somehow, in
this formulation, what you have is an implementation of qubits, and
secondly, you have a hint of how you're going to control this qubit from
the outside. How do you apply various gates? You now have this method of
reaching in and constraining the evolution of the quantum state.

* Aside

	One other thing which we may or may not get to is this whole notion of
  cooling. This is a big deal in quantum computing and quantum systems. How
  do you cool your system down to a desired level? Once you're down to the
  quantum level, cooling itself looks like an algorithm. So there's this
  notion of algorithmic cooling. Just wanted to point this out as a lead as
  to where we are going to get to in a few weeks.

* Intermission

Quantum Algorithms
==================
Inspiration
-----------
A one-qubit system belongs to $\mathbb{C}^2$; a two-qubit system belongs to
$\mathbb{C}^4$; an n-qubit system belongs to $\mathbb{C}^{2^n}$. This is a
result of repeated applications of the tensor product.

Note that even a 500-qubit system requires $2^{500}$ complex numbers to
describe. This number is larger than the number of particles in the
universe; larger than the estimated age of the universe in femtoseconds;
even larger than the product of these two numbers. This just comes from the
basic axioms of quantum mechanics. In order to even remember the state of
this 500-qubit system -- just to remember that state, it's almost as if
nature has $2^{500}$ pieces of scratch paper lying around somewhere.

Moreover, if the system interacts with something else, with the outside
world, the state needs to be updated -- it needs to be updated, even, at
every moment in time, at every smallest time step. If this were not a
theory which we read about in a science class, it's insane to think that
this is how hard nature must work to keep this tiny system going.

You have a choice, now. You can either get stuck in this philosophical
mode, or ignore how nature stores this information and just focus on how to
make use of this. A computer, once you get past the packaging, is just an
experiment in physics. The only difference between a computer and an
experiment in physics is that in an experiment in physics, you're trying to
understand how physics works, whereas when you're using a computer, you
already understand the physics and are just tricking nature to solve
interesting problems for you.

Furthermore, remember that entanglement disrupts the principle of locality.

So why use classical computers, when nature is working so hard to keep
track of these quantum systems?

It's almost as if quantum systems have the ability to store and process
exponential amounts of information. It's rather exciting: quantum mechanics
tells us that nature is exponentially extravagant. So you could solve
problems exponentially faster. But nature is extremely private. When you
make a measurement, all you see is one of these values. So this is the main
problem in quantum computing. You have this entity who, behind the scenes
is carrying out these totally extravagant gyrations, computations, and you
think to yourself, if we took our most difficult problems and mapped it
onto that? Except that nature also guards all of this very
jealously. Whenever you try to query, nature, tries to pretend nothing much
was going on.

So what quantum computation is about is trying to tease this information
out of nature. How do you design algorithms where you can really map the
question, the problem of interest, into this space such that even the
outcome of the measurement tells you a lot about the system?

We somehow take this 500-qubit system, put it into some state, and set it
to evolve over time. At the end of this time evolution, we make a
measurement and just get back 500 measly classical bits. We say to
ourselves, we couldn't have gotten them ourselves. Either these are the
solution to our problem, or we can post-process them very quickly to get
our solution. Even though this $x$ doesn't seem like much, there was a lot
going on to create $x$, and we can extract this information from $x$.

What we can solve in this manner are questions in the form of
puzzles. [ Description of NP-complete problems. ]

For example, the quantum algorithm for factoring, where you're given some
semiprime $n \equiv pq$ (although not really necessary) as input. We'll create some
sequence of superpositions, and we'll get $x$.

If $n$ were a few hundred bits, $x$ would be a few hundred bits, and we'd
be able to extract $p$ and $q$ in a fairly straightforward manner from
here. Except classically, this would take exponential time to compute (in a
few hundred bits).

What are the tools we'll be using? Hadamard gate, which is a one-qubit gate
corresponding to the two-dimensional DFT, or changing from the bit basis to
the sign basis (namely, between conjugate bases). This is our quantum
Fourier transform, most likely.

What we'll do next time is understand the transformation corresponding to
performing a Hadamard on every individual qubit.

<a name='13'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Algorithms
==================
Mar 1, 2012
-----------

Now, let me tell you what quantum algorithms look like. You have your
qubits feeding in, and you might have your input x, have a number of work
qubits initialized to $\ket{0}$, and you have your outputs. What we might
do is measure some subset of your output bits. And then what you might do
some classical post-processing.

So what happens inside the box? Inside the box, you have quantum gates that
form some sort of circuit.

For us, the star is the Hadamard transform (for now). Later, it'll be the
QFT, but the Hadamard is a good place to start.

Remember what we said was that we had n qubits. We'll call this $H^{\otimes
n}$ (an n-fold tensor product of 1-fold Hadamards). Suppose $H^{\otimes
n}\ket{0^n}$. What's the output? $\sum_{\ket{x}\in \{0,1\}^n} \frac{1}
{\sqrt{2}^n}\ket{x}$. Suppose $u$ is some n-bit string. Now what's the
output?

<a name='14'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Algorithms
==================
Mar 6, 2012
-----------
Today, we are going to resume our study of quantum algorithms, but I'll
start with the basics of what it means to have a quantum circuit in the
first place, and then we'll move on to a quantum algorithm.

Let's start with the first part, which is about the basics of designing
quantum algorithms. What circuits does one use, what does it mean to design
a circuit; things like that.

First question: Quantum computers are a) digital, b) analog. Why digital?
Input is a sequence of zeroes and ones; we input our qubits in some digital
form. Output is also in the form of zeroes of ones -- concept of
measurements.

Internally, qubits look both digital as well as analog: coefficient looks
analog; ket is digital. Really the coefficients are not analog, since we do
not care too much about infinite precision (cannot care, really). Where
else does it come from? It is unitary.

So it's not as though these are going to have chaotic dynamics; being off
by a little step doesn't spell the end of the world. No butterfly effect.

So that's lesson number one.

Lesson number two. So how did we actually design classical qubits,
classical circuits? There is this concept that certain gates that are
universal, e.g. NAND. Talk about how to construct all possible two-input
gates with NAND.

So: quantum gates. We have various examples of quantum gates, e.g. CNOT, H,
X, Z, $\frac{\pi}{8}$ rotations. So what do these mean? Suppose you have an
arbitrary gate U that we want to implement. Maybe it's a two-qubit gate;
maybe three; maybe one.

Remember, in this case, we can specify U by 16 complex numbers. But these
have infinite precision. We are not going to be able to implement infinite
precision with finitely many bits. So what we want to do is implement
something that is $\epsilon$ close to this. Instead use universal gates to
implement $U_\epsilon$. We'll measure this $\epsilon$, and we'll claim that
these two transformations are very close to each other (i.e. identical
states are sent to similar states; only changes distance by at most
$\epsilon$).

Also, the cost in terms of $\epsilon$ is not going to be very large. The
number of universal gates will scale just as $\log^2\frac{1}{\epsilon}$. So
all this, we're just going to take for granted. In fact, in our quantum
algorithms, we'll use relatively simple-looking gates.

So far, what we've learned is that quantum computers are digital, and
there's a universal family of gates.

These were both ways in which quantum computers were similar to classical
computers. Now let's start exploring the differences.

The first difference is that quantum computers are reversible.

You have some quantum circuit. It takes as input some number of qubits,
outputs the same number of qubits. Inside you have quantum gates. That is
your quantum circuit. $U_c$ is unitary, which means that $U_c^{-1} =
U_c^\dag$. In general, you will still get the mirror image, except you will
replace each gate by its Hermitian conjugate.

So now we have a problem. Suppose we have a classical circuit $C_n$ for
computing f. Now suppose $f$ is a boolean function, so $f(x)$ is just a
bit. Imagine there was a quantum circuit for doing this. We really are
computing all n bits. These other bits, together with f, allow us to
reconstruct $x$. Since quantum computers are reversible, any arbitrary
circuit is just a injective map.

Remember our basic classical circuit, our NAND gate. This was not injective
-- it mapped four possible inputs to two possible outputs.

Let's remember this qwuestion: why can't you just discard the bits that you
don't need? It turns out, this is a very crucial issue in quantum computing.

If this is a constraint that we have on our quantum circuits (unitary), we
have to do something: we have to make our classical circuits look like
this. We'll show that we can take any classical circuit and make it
reversible. So given a classical circuit, first make it reversible, then
we'll simulate it quantumly. That is our answer.

So how to make classical reversible computation? What you must do, if
you're doing classical computation reversibly, the first thing you must do
is increase the number of inputs. Now, being reversible means that it has
to be true at every step. You can't possibly throw away anything. You can't
ever discard information: you can transform it, but you cannot discard
it.

So now, what this shows is that you can take any classical circuit $C$
which has NOT gates and AND gates, and you can transform it into a
reversible circuit $R_c$ with more outputs (we need these to maintain
injectivity). We don't like this junk. What we'd like is to further
transform this into a circuit of the kind that we really like, $\hat{R_c}$,
that preserves the inputs as well as the desirable outputs.

The secret lies with the $CNOT$.

Back to what we did last time: suppose you had a boolean function $f$ and a
circuit $C$ that represented it. Now suppose you have a quantum equivalent
$U_f$. What we said was that since this is now a quantum circuit, we can
run it over a superposition of inputs.

Let's say you have a qubit that you feed into this circuit. What the
circuit does for you is it creates junk. It happens to be a CNOT
gate. Meaning, this was a circuit that on input $\ket{x0}$ outputs
$\ket{xx}$. However, suppose that we intended to do a Hadamard
transform. The "junk" prevents the interference that we desire. This is why
we do not leave junk lying around: we generally do not know what
interference it will cause, or where.

There's a corollary to all of this: **throwing away / discarding is the
same thing as measurement.**

So in other words, what all this shows you is that if you had a qubit and
wanted to measure it, one way to measure it would be to throw it away and
never interact with it again.

Claim: Measuring in the standard basis is equivalent to doing a CNOT, and
then continuing.

<a name='15'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Simon's Algorithm
=================
Mar 8, 2012
-----------
We're still working in this toy model. Last time, we showed that we can get
some sort of speedup for Fourier sampling. While this was on the order of
n, we can actually get a speedup of $2^n$

Review of Fourier sampling
--------------------------
Applying a Hadamard transform to all inputs, we get somme sort of analogue
to the FFT.

Adding slit patterns (going back and considering double-slit
experiment). Input corresponds to the slit pattern. And then, given the
slit pattern, we say it is hard to figure out what the interference pattern
looks like.

Simon's Algorithm
-----------------

We are given a circuit that computes a function. f is 2-1. Namely, there
are $2^n$ possible inputs, and there are $2^{n-1}$ possible outputs in a
particular way: there is some secret s of length n, and we know that $f(x)
= f(x \oplus s)$. Other than that, it could be anything. What you want to
do is find $s$.

Let $n = 3$. Let $s = 101$. So:

$$f(000) = f(101) \equiv 000
\\ f(001) = f(100) \equiv 010
\\ f(010) = f(111) \equiv 001
\\ f(001) = f(110) \equiv 100
$$

So how do you find s? Classically, you'd find two inputs that map to the
same string. You'd expect this to take roughly $2^{n/2}$ tries: consider
birthday paradox. What this is saying is classically, this is a hard
problem. And now we are going to see how to solve this quantumly in $n$ or
$n^2$ steps.

The first thing we are going to do is take this circuit (remember that if
we can compute something, we can also compute it reversibly) and write down
the reverse of this circuit.

Once this is a reversible circuit, we can also implement every gate
quantumly. We then map this to a quantum circuit which does the exact same
thing.

With the quantum circuit, you can input a superposition, and you'll get a
superposition of the outputs as your result. We've seen this before in the
form of phase states, but we'll use this in a different manner today.

Example:

We start with the Hadamard transform, $H^{\otimes n}$, and we feed in
zeroes. So what's the state at this point? It's a total superposition of
all states. After we feed this into our circuit, our state is a
superposition of the sum over all x of f(x).

Working through the math, we find that we get a random $y$ such that $s
\cdot y = 0$. Thus we have a single linear equation, and so we just need
$n-1$ equations to uniquely solve for s.

Okay. So let's go back and look at a general circuit. So we start with n
zeroes, do a Hadamard to get into a superposition of all possible
inputs. Now we are in the state where we have every $n$-bit state with equal
amplitude, but now it's entangled with this other register $f(x)$. At this
point, we measure these n bits (and we see some $f(z)$) -- and so we got
some random input.

Now we do another Hadamard transform and another measurement. We want to
figure out what we get as the result of this second measurement. We claim
that our output is a random $y$ such that $y \cdot s = 0$.

This is what we said before, but now more general.

Let's prove this. After the Hadamard, let's say we're in a state $\sum_y
\alpha_y \ket{y}$; $\alpha_y = \frac{1}{\sqrt{2}}(-1)^{z \cdot y} +
\frac{1}{\sqrt{2}}(-1)^{s \ cdot y}$. Now, we can see that this is equal to
zero if $s \cdot y = 1$ and two if $s \cdot y = 0$. Therefore the only
values remaining in this superposition are those such that $s \cdot y = 0$.

<a name='16'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Algorithms
==================
Mar 13, 2012
-----------
Today, we are going to set things up for the quantum factoring algorithm,
which we will cover on Thursday. To do that, we have to generalize the
Hadamard transform into the quantum Fourier transform. What we are going to
cover is the quantum Fourier transform: its properties as well as how to
use it.

Today, we'll regard period-finding as an abstract problem we want to
solve. Next time, we'll show how to use period-finding to factor.

So what's a quantum Fourier transform? It's really a quantum implementation
of the discrete Fourier transform.

So if $\omega$ is a primitive nth root of unity, then all of the powers
$\omega^j$ are also roots of unity.

So the quantum Fourier transform is going to look just like the Hadamard
transform except there are phases in it.

The discrete Fourier transform
------------------------------
$$
F = \frac{1}{\sqrt{n}}\begin{pmatrix}
1 & 1 & .. & 1
\\ 1 & \omega & \omega^2 & .
\\ . & . & . & . & .
\\ 1 & . & . & . & .
\end{pmatrix}
$$

$F_{jk}  = e^{ijk2\pi/n}$

Primitive square root of unity: $e^{i2\pi n}$. When we do $F_n$, it's the
same, but with phases.

Showing that $\braket{F_i}{F_j} = \delta_{ij}$...Properties of the Fourier Transform
-----------------------------------
This is a proper circuit, and in fact, you can implement it very very
efficiently.

The QFT is very efficient to implement by a quantum circuit.

Let's talk about what you'd get if you tried to implement it.

Considerations with regards to cyclic shifts: effect only shows up in
phases.

So by the way: in quantum computing, what is the significance of phases?
They don't matter in the context of a measurement.

To eliminate effects of relative phase, we do a Fourier transform and then
measure. Basically, multiplication-convolution property.

One more property of Fourier transforms, and then big picture.

The next property is the periodicity property of Fourier transforms. Part
of a much more general property that we won't talk about.

Suppose that $k\divides N$. Suppose that our superposition has period
k. The claim is that if you do a Fourier transform, you get something
that's periodic with period $N/k$ (time-frequency uncertainty
principle).

Note that this quantum Fourier transform can be implemented in $O(\log n)$
qubits, but only gives us the value at one index.

What I'll do for next time is to sweep some things under the rug; try to do
these things so very cleverly that you don't notice. Furthermore,
sometimes, if you see things too slowly, it's hard to understand. So next
time, I'll work hard to make sure that you see the big picture. So if
there's one lecture where you come in and think that you're going to be
fully alert, next time should be it.

<a name='17'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Factoring
==================
Mar 15, 2012
-----------
Introduction
============
Turns out that if you want to factor a number, it is sufficient to show
that we just need to split it up into its components.

The length of the input is $\log N$. That is, the number of bits.

So let's say that we've got a 1024-bit semiprime N. Linear is not at all
feasible -- larger number than age of universe in femtoseconds. So what we
want is to factor this in $\log N$. The best classical algorithms we have
run in some sort of exponential time.

So what we can see is a quantum algorithm that runs in time $\log^3 N or
\log^2 N$. All that matters is that it's polynomial with respect to $\log
N$. Now, factoring is extremely important because it is used in
cryptography -- RSA (which is behind various cryptographic schemes like
TLS).

Two things we'll need to understand: quantum subroutine -- finding the
period of a periodic function, and show how we can solve factoring using
this subroutine. For that, we'll need to understand something about modular
arithmetic. We'll use these to show how to go to factoring in polynomial
time.

Period-finding
==============
Given a periodic function f with period k such that $\{0, 1, ..., M-1\}
\mapsto S$ (i.e. $f(x) = f(x+k)$), assuming that we are working $\mod M$,
and k divides N, the challenge is to find k.

To appreciate this problem, think of M and k as being very large. You are
given some circuit for computing f: you input x, and you get as output
$f(x)$. This is a little like Simon's algorithm.

Now we're going to use M as the dimension of our quantum Fourier
transform. We'll do this quickly and somehow output k. So let's see how we
do that.

Recall properties of Fourier transform: convolution-multiplication property
(this manifests as phases applied to the output, and upon measurement, this
phase conveniently drops out), treatment of periodic functions ($\sum \ket
{jk} \fourier \sum \ket{j\frac{N}{k}}$) -- output is also periodic.

Our period-finding circuit will look very familiar. What we do is start
with a Fourier transform of dimension M, and input the state zero into this
Fourier transform. The result is a superposition over all states.

Now, let's feed this into $U_f$ (with enough scratch zeroes to fill all the
inputs), then measure the second register. Suppose we get some z as the
result of our measurement. What must the first register of $U_f$ be? A
superposition over all the states equal to $z \mod k$ ($\sqrt{\frac{k}{m}}
\sum_j\ket{jk + z}$). Now, if you measure this, you get a random number
$mod M$, which gives us nothing.

So what we want to do, therefore, is put this z into the phase so we can
ignore it, i.e. feed this into the quantum Fourier transform. Now we want
to measure. Now, measuring, we get some $r\frac{M}{k}$, where r is some
random integer between 0 and $k-1$. Recall, what we want is k. We can
consider the gcd of different measurements. Presumably if we sample a few
times and take the gcd, then this will readily lead to our goal. (note that
our samples must be collectively relatively prime in order for us to get
the correct answer, so $\log N$ samples is an approximate upper bound).

Note that the gcd can be found quickly using Euclid's algorithm.

Shor's Algorithm
================
So now we want to factor. This algorithm works for any number, but for now,
we're concerned only with semiprimes: $N = pq$, for $p,q$ prime.

Here's a claim: Given that you can solve this problem (order-finding), then
you can factor. Let $ord_N(x) =$ order of $x$. (the minimum $r > 0$ such
that $x^r = 1 (\mod N)$ -- this exists iff x relatively prime to N
(Fermat's Little Theorem). This assumes that $\mathtt{gcd}(x,N) = 1$ -- if
it isn't, then we can trivially factor.

The claim is that if you can find the order of $x \mod N$, you can
factor. Classically, this wasn't even considered because finding the order
of $x$ was potentially more difficult than factoring. But now we have this
completely magical period-finding algorithm.

Claim: if the order is even and $x^{r/2} \neq -1$, one factor is either
$gcd(N, x^{r/2} - 1)$ or $gcd(N, x^{r-2} + 1)$. Somehow, once you've
figured out the order, it's easy to find the factors: this is for a very
good reason.

There's a secret fact: if N is a composite, when you take the square root
of one, you have more than just $\pm 1$. These square roots are great,
because once you've found them, you've factored the number.

Consider this:

$$\newcommand{\divides}{\big|}
x^{r/2} \neq \pm 1
\\ y \neq \pm 1
\\ y \pm 0
\\ N \not\divides\;\; y
$$

Thus

$$
x^r = 1
\\ y^2 = 1
\\ y^2 - 1 = 0
\\ N \divides y^2 - 1
\\ N \divides (y+1)(y-1)
$$

We exploit the periodicity of modular exponentiation: f is periodic with
period r (the order). Thus we can use the period-finding algorithm to
determine the order of x.

Thus to factor N, we pick x at random mod N and use the function $f(a) =
x^a$ in our period-finding subroutine. What does a subroutine do? We invoke
the subroutine many times, and each time we get some number, and we take
the gcd... and eventually, from the subroutine, we get r.

Repeat this until r is even and $x^{r/2} \equiv -1$.

Compute $gcd(x^{r/2} + 1, N)$ and output this.

Recap
=====

Note that what we stressed here was the quantum part of this algorithm. If
you wish, you can see the details of the modular arithmetic: chapter 0
in CS170 text. For those of you who have the background, last chapter.

<a name='18'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Search
==============
Mar 20, 2012
------------

This is the main problem with quantum algorithms, that you're sort of
searching for a needle in a haystack.

So how long does it take? Usually a function of how large the haystack
is. One way to think of it is that you have a table with n entries, and one
of these is marked, and you're looking for the marked entry.

So classically, you could of course try every entry until you find the
marked one, which takes on the order of n steps. Randomized, you could
expect to find it halfway through your search.

What we're going to see today is called Grover's algorithm. It's a quantum
algorithm that does this in $\sqrt{n}$ steps. It's very strange in that you
get to know without looking at all of the steps.

So... what does this have to do with anything? In general, when we are
trying to find an algorithm for something (when we are trying to solve a
computational problem), our problem is as follows: given some input x, we
want to find something. Whether this is 3-SAT, TSP, factoring; we want to
find some output (answer).

Often finding the answer is difficult, but once you have it, you can
convince yourself that it's a good answer (i.e. it's in NP).

There's a real dichotomy: searching for an answer might be exponentially
hard, but checking said answer is easy (i.e. verifiable in polynomial
time).

It turns out that even though checking the answer is easy, we *believe*
that finding the answer is hard. There are all sorts of problems in
here. We strongly believe that $\mathrm{P} \neq \mathrm{NP}$. What we can
show is that if there are hard problems, then the NP-complete problems are
definitely hard.

Remember, all NP-complete problems are just search problems. So this
searching for a needle in a haystack is actually at the crux of these
problems.

Thus with Grover's algorithm, we can get a quadratic speedup for these
NP-complete problems.

Given a function $f \{1 .. N\} \mapsto \{0, 1\}$, find x such that $f(x) =
1$. We'll focus on the hardest case where we have only one possible x.

We could also convert this into a quantum circuit. Now, we can feed in a
superposition of states, and you'll get the same superposition of
corresponding outputs.

What the algorithm will do
==========================

Let's consider $N = 2^n$. The way our algorithm will work is that it'll
start with this superposition of all these states. How do we do that? A
Hadamard.

Then we apply the function, then apply a bit flip (X). All of the states of
our superposition that correspond to zeroes are now ones, and the one state
that corresponds to one is now zero.

If you were to consider these amplitudes and compute the arithmetic mean,
it's approximately $\frac{1}{\sqrt{N}}$. So what we're going to do is this
really funny operation; we're going to reflect all these amplitudes about
the mean. If it's above the mean, it goes below the mean by an equal
amount; if it's below the mean, it goes above the mean by an equal
amount. We can iterate this until roughly the halfway point.

This particular algorithm is called the quantum algorithm for searching a
database, which is nonsense. In order to use a quantum algorithm, you must
first feed the entire database into the quantum algorithm. Even if
searching took a single step, you've already taken n steps to convert it.

The entire point of this algorithm is to search for a Travelling Salesman
path, for instance.

Implementing
============

We'll start by doing a Hadamard on our original state of zeroes, and now
we'll have our superposition over all states.

For the second step, the suggestion is that we should use the circuit for
$f(x)$.

The third step is strange: it's a reflection about the mean. So what's the
mean? $\mu = \sum x\alpha^2_x \ket{\alpha_x}$. Let's first understand what
it means to reflect about the state $\ket{0^n}$. We leave alone the
component in the $\ket{0^n}$ direction and flip the phase of every other
component. So a reflection about $\ket{0^n}$ would look like
$\begin{pmatrix} 1 & 0 & 0 & ... \\ 0 & -1 & 0 & ... \\ 0 & 0 & -1 & ... \\
... & ... & ... & ...\end{pmatrix}$. So how do we do this for the uniform
vector? We simply do a change of basis such that this is our zero vector,
do this operation, then revert our basis. This is usually called D, our
diffusion operator. $D = H^{\otimes n} Z^\prime H^{\otimes n}$.

Replacing each $\alpha_j$ with $\beta_j \equiv 2\mu - \alpha_j$ is just the
reflection about the mean.

Actual circuit
==============

We know how to do the first two stages. Then we want this special
transformation: first do a Hadamard, then reflect about $\ket{0^n}$. We
have a function that outputs one whenever this isn't $\ket{0^n}$ --
something we can implement classically, so this is not a problem -- then we
can feed this into our conditional phase flip.

The important thing about these algorithms is that they have special
structure, and so they have small corresponding quantum circuits.

<a name='19'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Guest lectures: implementation of qubits
========================================
April 3, 2012
-------------

Kevin Young: kcyoung@berkeley.edu

We'll start with how to implement qubits using spins, and eventually
culminate in NMR.

Today, what we're going to do is start looking at physical implementations
of QC. Will continue through the end of next week. How to build an actual
physical quantum computer. Implementation choice: NMR (one of first QC
where a quantum algorithm was demonstrated).

Start with basics, i.e. fundamental building blocks: spin qubits. Approach:
start with experiments people did quite a while ago, back when people were
still trying to understand QM, what systems were quantized. The experiments
we're going to look at, we're going to use their results to build up a
physical theory and apply this theory to qubits. We're going to look at how
this gives us nice pictures to use.

Ultimate goal of lecture: understand how to write down the state and work
with the state of a two-level system.

We're going to start out with some experimental results, assuming we know
enough QM to push us along a little bit: understand quantum states and how
they work. Not going to necessarily understand right away what quantum
model we can use to describe these experiments.

Backdrop: look at experiment called the Stern-Gerlach device. Conflicting
theories about how magnetic field of small atoms should behave. Two
theories. One: electrons should act like little tiny bar magnets ("bar
magnet theory") -- one feature: these acted like classical bar magnets --
magnetic dipoles that can be oriented arbitrarily in a magnetic field. Two:
in light of all this new QM, in the presence of a magnetic field, then this
bar magnet should only take one of two possible directions: up and down
(quantum theory).

Simple experiment: looking at how classical bar magnets behave in magnetic
fields. Background: if I put a bar magnet in a magnetic field, the
classical description corresponds to how much energy it has depending on
its orientation. Since bar magnets like to align with magnetic fields, you
can write down that energy $U = -\vec{\mu} \cdot \vec{B}$. B is the
magnetic field; $\mu$ is the magnetic dipole moment. If parallel, we have a
relative energy of -1, and if antiparallel, we have a relative energy of 1
(relatively high energy). Shows that dipole likes to be aligned with
magnetic field.

What Stern and Gerlach noticed was that we can separate out parallel from
antiparallel by making the magnetic field not constant. The magnetic moment
is aligned with the field, so in this case, energy is just $-\mu B$. So the
energy will go down if magnetic field goes up. Reasoning: objects want to
move to lower potentials. Wants to bend toward area where potential energy
is lower. If dipole is pointed up, it'll move and point down.

Now let's say we had an oven, and by saying it's an oven, we mean that it
just spits out a continuous stream of these quantum or classical dipoles of
totally random spins (as random as the theory will allow), and we connect
the output of this oven to a SG machine. Let's say we have quantum dipoles
coming out of that oven. In the quantum model, on the screen, we will see
two points (for the most part). The classical theory predicts a continuous
distribution.

Saw two peaks.

Reasoning for the classical result to not be flat: orientation is uniformly
chosen from points on unit sphere.

Argument of Summerfeld (quantum theory): wrong theory, but correct results.

So more playing around with SG experiment. Oven spits out these completely
random quantum particles. And then it hits this device. One of the things
we need to do is give it a label corresponding to direction of magnetic
field. We can label this by $\hat{n}$. What we're going to get out is two
beams. We're going to label these two beams the same way we labeled the SG
device. We'll label the top one using some quantum notation we've already
learned. For now, we'll call these $\ket{\hat{n}^+}$ and
$\ket{\hat{n}^-}$. Check if these are appropriate labels by feeding into a
second SG device, also pointing the same direction.

Saw only one beam coming out in the same direction as the other one. This
is a little bit affirming. I can do an experiment that is effectively
measuring something: the alignment (or anti-alignment) with the field lines
of the box. Measurements; since we measure again in the same basis, we get
the same result.

Nice, interesting result, but now let's change the situation again. Now we
have $\hat{n}$, and we only let $\ket{\hat{n^+}}$ through. Now this second
box is pointed in a different direction. What do we get if m is very close
to n?  $\ket{\hat{m}^+}$ is very bright (relatively). Probability of $+$ is
$\frac{1}{2}(1 + \hat{m} \cdot \hat{n})$, and probability of $n$ is
$\frac{1}{2}(1 - \hat{m} \cdot \hat{n})$. How do we find probabilities in
QM? Squared inner product.

These equations relate the experiment to a theory we haven't figured out
yet. So we need to figure out a way to describe this. SG as entangling
degrees of freedom.

So: back to what we were talking about before. Must build physical theory
that is consistent with these relationships. One thing we haven't done yet:
(we know these things are quantum states) decide dimensionality. We can
always write these as vectors, but how many numbers are we going to need to
describe these. We need two numbers to describe the points on a
2-sphere. Fundamental: only got two answers out. The simplest picture that
you could imagine is that you have a 2-level quantum system. If all of your
experiments could be described by two outputs, then the first thing that it
might be worth trying is describing this quantum state with a
2-vector. Could be wrong, but it's a good place to start.

In physics we really like things that are up and down, so we'll give these
special names. Instead of calling these $\ket{z^+}$ and $\ket{z^-}$, we'll
call these $\ket{0}$ and $\ket{1}$. Represent all these $\hat{n}$ states in
terms of $\ket{0}$ and $\ket{1}$. We know that if in fact our system is a
2-dimensional quantum system, $\hat{n} = \alpha\ket{0} + \beta\ket{1}$. So
what we're going to figure out is if we can determine $\alpha,
\beta$. Something useful: go back to polar (spherical) coords. What we're
going to do now is see if we can figure out something about $\alpha$,
$\beta$. We know that if we choose $\ket{0}$, then $\ket{0} \equiv
\ket{z^+}$. (z is direction SG device points). We want to see if we can
write $\ket{n^+}$ in terms of zeros and ones.

Working out the math, we get $\abs{\alpha} = \cos\frac{\theta}{2},
\abs{\beta} = \sin\frac{\theta}{2}$. However, we don't have phases
(yet).

Note that we don't care about absolute phases; relative phases are all that
actually matter (reasoning: we can multiply through by some complex
exponential to cancel out the phase on one term).

Let's say that an x SG device is moving, and it hits a y SG device, and it
outputs $\ket{y^+}, \ket{y^-}$. Only difference between these states is
the absolute phase (rather, the relative phase between the two states).

Working out the math (once again), we get $\frac{1}{2}\parens{1 +
\cos(\lambda_y - \lambda_x)} = \frac{1}{2}$, so $\lambda_y, \lambda_x$ are
perpendicular (relative phase is $\frac{\pi}{2}$).

What this tells me is that I can represent any quantum state as a unit
vector. So if I have some state $\ket{n^+}$, I can associate it with a point on
a unit sphere. This picture also tells me that $\ket{n^-}$ is the opposite
point on the sphere. Orthogonal states correspond to antiparallel vectors
(antipodal points).

<a name='20'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Guest lectures: implementation of qubits
========================================
April 5, 2012
-------------
Recap: last time, we covered SG machines and the possibility of expressing
states as points on an n-sphere (by specifying n angles). Punchline:
one-to-one correspondence between states in a two-level system and points
on the 2-sphere.

One of the things we did on Tuesday was send these states through devices
that measured their states. Summarizing all we know about measurements: if
we can talk about some measurement (that corresponds to a Hermitian
operator), and we have some device that takes some unknown state
$\ket{\psi}$ and output two beams that are orthogonal (on the Bloch-sphere,
these are antipodal points); if I repeat the same measurement immediately,
then we'll get the same result.

A measurement corresponds to a Hermitian operator, and each measurement
outcome is one of the eigenvalues of that operator. Why do we consider
Hermitian operators? Diagonalizable with orthonormal eigenbasis
corresponding to real eigenvalues (i.e. spectral theorem).

What we want to do is construct a matrix to represent this measurement. We
first need some sort of matrix representation of our kets. Taking advantage
of the fact that we have Hermitian operators, some operator Q always has a
diagonalization $SDS^\dag$.

(constructing the bit flip (NOT) gate X, which was most of a problem on the
QM midterm yesterday :D)

One thing that's going to be on your homework is that $S(\hat{n})
\ket{\hat{n}}$ is going to be the matrix that returns +1 for

Pauli matrices $Z = \begin{pmatrix}1 & 0 \\ 0 & -1\end{pmatrix}$, $X =
\begin{pmatrix}0 & 1\\ 1 & 0\end{pmatrix}$, $Y = \begin{pmatrix}0 & -i\\ i
& 0 \end{pmatrix}$.

Physicists refer to these as $\sigma_x, \sigma_y, \sigma_z$. These
correspond to some way of measuring the spin. If I send some random state
through here, I can figure out the expectation value of that state using
these operators. Let's say I have some state $\hat{n}$, and I stick it
through the Z block. I'm going to get out some zeros and some ones. I
learned from experiment that the probability of getting zero is
$\frac{1}{2}(1 + \hat{n} \cdot \vec{z})$, etc.

($\vec{S} \equiv \hat{X}\ket{0} + \hat{Y}\ket{1} + \hat{Z}\ket{2}$; it's a
vector of matrices)

Expectation we can calculate in one of several ways: $\sum_i \prob{x_i}
x_i$; $\braKet{\hat{n}}{Z}{\hat{n}}$. They give the same answer, which is
encouraging.

We can start to write the (quantum) Hamiltonian of the system with
electrons in a magnetic field: $\mu B \cos\theta$. We're assuming $\mu, B$
constant. Considering the Hamiltonian to be $-\mu B\hat{Z}$, the
expectation value is certainly what we expect, so we'll go into a more
advanced case: $H = -\mu \vec{B} \cdot \vec{S}$. In physics, for an
electron, this is the Bohr magneton $-\frac{e\hbar}{2m}$, so it's
negative. NMR uses radio waves; electron spin radiance uses
microwaves. This is just due to the difference in the magneton.

This in a way corresponds to a classical description. The thing is to see
how that Hamiltonian affects states.

$H = -\mu_0 B_0 Z$. What describes time evolution of a quantum system?
Time-dependent SE. Solution is $\Psi(t) = \exp(-\frac{i}{\hbar} H t)
\ket{\Psi(0)}$. What this means is that $\ket{\Psi(t + dt)} = (1 -
\frac{i}{\hbar} H dt) \ket{\Psi}$. Taylor series tends to be a terrible way
to exponentiate matrices, since the radius of convergence is really
small. However, we get lucky because these are Hermitian matrices, so they
are diagonalizable with real eigenvalues, which is easy to do quickly.

Pauli matrices are especially nice in that they actually alternate between
themselves and the identity. This has interesting results: $e^{i\theta X} =
I\cos\theta + iX\sin\theta$; $e^{i\theta \hat{n} \cdot \vec{S}} = I \cos
theta + i(\hat{n} \cdot \vec{S})\cos\theta$. This shows up a lot since
physicists tend to pick magnetic field as Z. Originally devised by Zeeman,
so it'll often be known as the Zeeman Hamiltonian or the Zeeman effect.

The system precesses. This misbehavior is analogous to internal angular
momentum in classical mechanics.

Peculiar property of fermions (half-integer spins). Requires two
revolutions. (twists relative to the universe?) At this level, easiest to
understand as the cost of having this nice physical picture. We're really
doing rotations on complex vector spaces.

Limitation of this picture is that it's only half of the representations we
can do in the complex space.

<a name='22'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Guest lectures: implementation of qubits
========================================
April 12, 2012
--------------
(notes from last time were on paper)

One last homework due next week. Will give feedback on projects after
that. 3 multi-part problems. Should not be too hard.

Review: we can do arbitrary single-qubit gates. Wrote down expressions for
doing arbitrary phase rotations. THe simplest model for two qubits
interacting with each other that feels like $H_{int} = J\sigma_z^{(1)}
\otimes \sigma_z^{(2)}$. If we were in a single qubit, we chose special
states: $\ket{0},\ket{1}$. Eigenstates of $\sigma_z$. Arbitrary
superposition of these.

When we have two qubits, we can pick a similar basis, but now our system is
composed of 2 qubits, so we need four basis states (can easily form these
by taking tensor products of our previous basis states).

effective magnetic field of the qubit is itself measured by a Pauli
operator.

If we want to build a matrix representation of an operator, we just need to
know how it acts on each of our basis states. To set up our conventions,
$\sigma_z\ket{0} = 0$; $\sigma_z\ket{1} = -\ket{1}$.

If J positive, favors antialigned (antiferromagnetic); if J negative,
favors aligned (ferromagnetic). Condensed-matter people love to study
antiferromagnetic things. End up with frustration in triangle lattice.

The way we construct the tensor product matrix is by sticking the second
matrix B onto each element of A. What I mean by that is that $A \otimes B
\equiv \begin{pmatrix}A_11 B & A_{12}B & ... \\ A_{21}B & ... & ...
\\ ... & ... & ...\end{pmatrix}$. It's worth your time to convince yourself
that this is the right way to do the tensor product. Think about how you're
writing down your basis states.

Now that we have this operator, let's think about what it does to our
system. Let's look at it strictly from the lab frame. So we're not going to
take out the Larmor precession. Write out full Hamiltonian.

$H = \mu_0 B_1 \sigma_z \tensor I - \mu_0 B_2 \sigma_z \otimes I + J
\sigma_z \otimes \sigma_z$. One thing you can do is look at the spectrum of
the Hamiltonian: the available energies (eigenvalues of Hamiltonian).

By putting an interaction on these two qubits, I've given myself some way
of doing a CNOT: a nontrivial tensor product. One thing that is important
is that these qubits are indistinguishable somehow. If I want to control
one but not the other, they need different resonance frequencies. If you're
going to pick some molecule to stick in your quantum computer, you can't
choose one with the usual symmetries. Something like plain acetylene
wouldn't really work wekk: both carbons have the same
environment. Indistinguishable. But by replacing one hydrogen by a
deuterium, we've changed the resonant frequency by just a little bit so
that our system is now resolvable.

Let's go back into a rotating frame. In a rotating frame, what we've done
is subtract out the rotating part of the hamiltonian. We can still do the
same mathematical transformation. Why? These operators commute. Two
different systems, so you can know both simultaneously. No uncertainty
relation.

Notice that the state $\ket{00}$ and $\ket{11}$ get a positive phase after
some time t, and $\ket{01}$ and $\ket{10}$ get a negative phase after some
time t. Recall that the $\pi$-pulse changes the parity of a state: it takes
an even-parity state and switches it to an odd parity state.

First is hamiltonian evolution for time $\tau$, and second, we do an X-gate
on the first qubit, and then third, we do hamiltonian evolution again for
$\tau$, and fourth, we do our X-gate again. I'll do 0 explicitly. We start
out in the state $\ket{00}$. Hamiltonian evolution (for this system) under
a time t looks like $e^{-J\tau}\ket{00}$. After the second step, we move
into the state $e^{-J\tau}\ket{10}$. After the third step, we have the
state $e^{J\tau - J\tau}\ket{10}$. And then, after the fourth step, we get
back $\ket{00}$. So by doing this series of operations, I've effectively
eliminated the effect of this hamiltonian (not ideal, but has the same net
result.)

This procedure is going to be very important to us: dipolar
decoupling. It's dipolar because you're dealing with these magnetic
dipoles, and this interaction in a sense couples these two qubits, and
you've turned this interaction off. On Tuesday, we'll talk about dynamic
decoupling, where it's basically the same procedure used to eliminate
noise.

One of the assumptions we've made is that the X-gate is fast compared to
$\tau$. It takes some time to do that X-gate, and while that's happening,
the system is evolving, and so you're accumulating some errors. Problem
with doing these X-gates fast.

Let's think of the exact sequence of controls we need to do to implement a
Bell state. So the first thing we do is the dipolar decoupling, as
discussed, so that we have the same state after some time has elapsed. Now,
we have to do a Hadamard gate: sequence of X, Y pulses that looked like
$X(\pi/2), Y(\pi/4), X(\pi/2)$. Now we want to do a CNOT by applying a
$\pi$-pulse at one of the frequencies.

This sequence of operations gives us exactly the Bell state that we wanted.

When you start building a larger quantum computer, the idle times start
becoming vital: even worse than we've discussed (Tuesday).

A lot of pulse-design for NMR revolves around faulty gates: how can I make
these errors cancel each other out?

<a name='23'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Guest lectures: implementation of qubits
========================================
April 17, 2012
--------------

Last time, we talked about two-qubit gates. Today, we're going to talk
about why NMR quantum computers are not scalable and dephasing/decoherence.

So, one of the most successful demonstrations of an NMR quantum computer so
far was factoring the number 15. Used a molecule $F^{19}C^{13}$ as their
nuclear spins, and then iron, etc. In order to construct a molecule to use
it in a quantum computer, each qubit must be in a different local
environment so that the spectrometer can see a different resonant frequency
for each qubit.

Carbon exists with several different isotopes: $C^{13}$ has spin
$\frac{1}{2}$, for instance.

Carbons are easy to distinguish. Either surrounded by fluorines (very
electronegative) or irons (metals).

Also not just using one of these: fill up generously-sized sample-holder,
and you end up with ~$10^{22}$. Also important: this system is generally
analysed at room temperature. At room temperature, the effect of thermal
excitations on quantum systems is fairly large. Back-of-the-envelope way of
estimating whether you're in the ground state or not: if your energy gap is
very big compared to $\tau$, you'll likely be in the ground state. But
typically in NMR systems, the converse is true: energy gap is very small.

Density matrices
----------------
Quantum mechanics is frequently concerned with quantum probabilities
(intensities of the wave function, so to speak). These are not the only
probabilities we can consider.

Person flips a coin. If heads, gives state $\ket{\psi}$. If you're doing an
experiment and measure, what you want to do is describe what's coming out
consistently. One way: describe state as list of tuples,
e.g. [(.5 0) (.5 1)]. Not very useful. Expectation of operator A:
$\braKet{\psi}{A}{\psi}$.

trace of $\rho_A$. Density matrix: if probabilities sum up to 1, trace of
density matrix is 1.

Remember Bloch sphere: states on Bloch sphere describe quantum states. If I
have some probabilistic sum, the density matrix $\rho$ is $\sum_k p_k
\ketbra{\psi_k}{\psi_k}$. For a single qubit, I'm interested in making
measurements. The measurements I usually have access to are the Pauli
matrices (plus the identity), which form a basis for all Hermitian matrices
for two-level systems -- quaternion lie group, almost. Pauli matrices are
traceless.

Thus I can write the density matrix in terms of these quaternions. $\rho$,
then, will be $aI + b\sigma_x + c\sigma_y + d\sigma_z$. All I have to do,
now, is figure out a,b,c,d. I know that the trace of $\rho$ is 1, so a must
be $\frac{1}{2}$.

Now let's say I want to take the expectation value of $\sigma_x$. That's
equal to the trace of $\rho \sigma_x$. Working this out, we get b is
$\frac{1}{2}\avg{\sigma_x}$. The rest follows in a similar
manner. (remember that $\sigma_i\sigma_j = \sigma_k\epsilon{ijk} +
\sigma_i\delta_{ij}$)

Something else is really nice here: you know that pure states are such that
the expectations of $\sigma_x$, $\sigma_y$, $\sigma_z$ are easy to
calculate: the state is an eigenstate of $\hat{n} \cdot \vec{S}$.

We can now say something: pure states live on the Bloch sphere, while mixed
states live within the Bloch sphere.

No measurements that can distinguish between states with same density
matrix. Completely mixed state.

Decoherence
-----------
How these things evolve over time. Populations, coherences. Time evolution:
rewrite as $\int p_b \rho_b db$.

Populations and coherences: intuition is notion of coherent superposition
vs. incoherent superposition (classical prob. of up, classical prob. of
down; off-diagonal terms are 0).

Start having quantum coherences $\implies$ values showing up in
off-diagonal terms.

Magnetic field will just cause phase to go around at some rate.

Hahn (?) echo to extend coherence: only if magnetic field is not
fluctuating. Great at eliminating low-frequency noise.

In an NMR system, you tend to have inhomogeneous broadening.

Decoherence comes in two favors: both flavors are very bad. This is called
dephasing: losing the phase from the system. Typically comes with a time
scale, $t_2$. If you do this series of Hahn echos, the coherence will very
quickly decay. Remember, these magnetic fields are slightly fluctuating.

$t_2^*$ is decay that gets almost completely eliminated by Hahn echos, so
less relevant, generally.

There's another type of decoherence: suppose I set up my state in the
excited state. Could be noise that relaxes the state to the ground
state. This relaxation is given by time $t_1$. If you set up some state on
the Bloch sphere, and you don't do your complication very quickly, it'll
start to decohere.

$t_2$ is controllable. Can utilize correlations of that noise, various
techniques to mitigate its effects. Relaxation very difficult to eliminate:
what you could try is symmetrization. Can never get this echoing
behavior. Eventually, all of these states will go down to the mixed
state. Eventually all the states tend toward the zero state if there's
relaxation.

Decay of magnetization; Bloch equations. Decay in certain directions
corresponds to certain time constants. So that's about everything. Did want
to talk for a few seconds what happens when you try to scale NMR.

Because you have these thermal issues, you can't prepare the ground state
in exactly where you want. You want everything in the ground state. Because
of thermal issues, you have a probability of being in all of the
states. Make something called a pseudo-pure state. $\epsilon$ times the
ground state plus $1-\epsilon$ times the fully-mixed state. When you start
adding qubits (e.g. with 7), $\epsilon$ gets smaller. If you get 100 qubits
(molecule with 100 different spins on it) and a standard sample size,
there's 100 qubits per molecule. There's a 99.9999999% chance you have 0
molecules sitting in the ground state.

Also, the colder your system gets, that's certainly better, but you need to
push those temperatures really low, and at some point you're not doing
liquid-state NMR any more (molecules are just tumbling; dipolar coupling
between molecules balances out, very narrow lines), you're dealing with
solid-state NMR (broadening of lines). Ways of coping: magic-angle spinning
-- narrows lines a bit.

Thursday: Haffner will come back to talk a bit more about another
system. Umesh will then come back to talk about AQC and quantum crypto.

<a name='24'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Guest lectures: Experimental Quantum Computing
==============================================
April 19, 2012
--------------
Professor Haffner: will speak about experimental QC. One of leading experts
in ion traps.

Specific impl. of quant. information prcessing. Idea is fueled by building
a scalable quantum processing device for whatever motivation you have. Many
approaches. What people thought 10-15 years ago: landscape has not actually
changed too much in recent years. Couple options shown to not work; most
likely will; and some have made progress.

Implementation of qubits: initialization of quantum registers, logic
operations, maintaining coherence. NMR initially very successfully, but
could be shown that this technology not scalable: exponential cost for
initialization: prob of finding particle in ground state drops
exponentially with no. of qubits because simply the prob of being in ground
state decreases.

Concentration for today: trapped ions. Mention: superconducting quantum
bits -- new, looks promising.

Picture of quantum computer. Quite complicated. Important thing: realize
that the physics is very simple, and that's what you need for quantum
processing device: very isolated, very clean. All in this vacuum chamber
(rest is just tools). Ion trap: by applying correct voltages, we can
confine single ions. trapping direction much stronger radially than
axially. Distance from each other on order of $5\mu\mathrm{m}$. These ions
are what we call quantum bits: nothing but two-level system: we forget
about all other levels. Particular excited state: chose $D_{3/2}$
(implementation detail). Transition is a two-photon transition: has two
angular momenta. Unlikely to drop (since it needs to spit out two photons),
so we have about a second for quantum processing.

We also have this p-level around. Very important in this context, since it
allows us to see the ions.

Di Vincenzo criteria:

# Scalable physical system, well-characterized qubits.

# Ability to initialize the state of the qubits

(need to set up a system)

# Long relevant coherence times, much longer than gate operation time

(require this to be quantum, and we need to be able to implement arbitrary
operations)

# Universal set of quantum gates

# Qubit-specific measurement capability

(need to be able to read it out)


No infinitely-scalable system (believed to be finite particles in
universe), so we mean mostly-scalable, i.e. not exponential to scale.

Experimental procedure: initialization in a pure quantum state. Very high
probabilities: the idea is that you exploit large differences of coherence
times. (done by shining lasers)

Quantum state manipulation: also done with lasers.

Quantum state measurement by fluorescence detection (every 10 ns I get a
photon into a $4\pi$ solid angle, etc. From a quantum mechanical view, this
is pretty interesting: prepare in s,d, and start scattering photons, and
the ion decides whether it's light or dark. Also works with multiple
ions. Instead of zero and one, I will use s and d since I am talking about
physical images.

With very high fidelity (~99.99%) we can detect this state. Essentially
limited by time it takes for the d state to the ground state. Many orders
of magnitude better than other implementations.

What we do now is initialize in ground state, shine in laser for a given
time, then read out dark or bright, then plot probability. Then you see
oscillations that correspond to the Bloch sphere, and you plot these.

How do we distinguish between $s+d$ and $s+id$? What does that mean? What
does that phase mean? I can shine in this laser and stop here. Might have
also noticed I can prepare in $s$ state; how can I prepare in $is$ state?
This problem of the phase occurs because in quantum mechanics, you must be
especially careful regarding what you can observe. Will show experiments.

So what is this phase about? For this phase, you need a phase
reference. The two phases we will have are the phase of the laser field and
the phase of the atomic polarization. Assume for now that we have a
dipole transition, not a quadrupole transition. $s$ and $p$ state. If I
look at where my electron is, I will find that in the upper part it
interferes constructively, but from the timing-dependent Schrodinger
equation, relative phase is governed by energy difference. What this means
is that you can have a minus sign, and it will be found lower.

The electron probability moves up and down with energy difference between s
and p state. Exactly the optical frequency: laser frequency. If I want to
drive transition, must apply laser matching that energy difference.

Atom with atomic polarization that goes up and down: how laser can drive
transition. Electric field shakes electron. If phase right, I can increase
this dipole moment. If phase wrong, I get destructive interference.

By switching laser phase by $\frac{\pi}{2}$, we switch from constructive to
destructive interference. By shifting the phase by this amount, we're not
putting any more energy in the system, so it's not evolving.

When I switch the phase, I am no longer rotating about the x, but now the
y.

So far we were talking about single ions. Now consider multiple ions (where
most problems show up).

change voltage by electrooptic deflector: deflects light beam based on
voltage. Neightboring ions are hardly excited. Residual excitation of cost
here since never really zero. Way to correct: apply dipolar decoupling.

Suppose you are ~1 A, and your neighboring ion is about 50 $\mu \mathrm{m}$
away. Exploiting here: ions move together. Coulombic attraction. Two
pendula coupled by a spring have normal modes. Most common is center of
mass mode where all ions move together. All have different frequencies. Can
use laser to excite these modes. Main mechanism: selectively push on one
ion with a laser.

Review of quantum mechanics of harmonic oscillators. Four levels: display
slightly differently. Combination of two-level system with harmonic
oscillator. Plot energy, label different states. Ion beam at ground
state. Electron ground state, electron excited state, etc. And then I can
apply a laser to drive this electron transition.

Think of it really as a ball being at the bottom of some harmonic
potential. Very crude approximation. Point is that we can think of this as
an abstract Hilbert space which you can connect with lasers. Same
frequency: carrier transition. In this transition, motion is not
changed. Then we can detune the laser; we have energy conservation at
particular energies.

Blue side-bands, since blue-shifted, etc. Frequency multiplied by
$\hbar$. When you scan the laser frequency, you can see some
excitations. There are other excitation probabilities. Three harmonic
oscillators, since we're working with three dimensions. Radial modes,
radial minus axial modes, etc. Can also do transitions where excitation of
state destroys a photon. Raising and lowering operators.

e.g. radial production of phonons, axial destruction of phonons.

What we can do, for instance, is increase motion in one direction while
decreasing it in another direction.

You learn things like dipole-forbidden. It's really a quadrupole
transition, suppressed by $\alpha^2$. Gives the difference of 10ns
vs. 1s. Don't worry about details.

We looked already at this exciting the electronic transition. Can also tune
laser to sideband, and see more Rabi oscillations with Rabi frequencies:
Reduced by $\eta = kx_0$ Lamb-Dicke parameter. Can calculate; actually
probably would take an hour as well.

Let us now create some Bell states. See how we can use this toolbox to
create Bell states. Take two ions prepared in s state, but also
laser-cooled center of mass to ground state. Doppler effect. What we do now
is three pulses: first a pulse onto right ion for a length $\pi$ on the
carrier transition, i.e. flip state but not motion. Now, go with laser to
other ion and apply a blue side-band pulse for length $\frac{\pi}{2}$. And
now we have the last pulse, which will somehow create the bell
state. Tuning our laser to the right ion and applying a $\pi$-pulse. What's
happening is we go to the s state and remove a photon excitation. We
de-excite the motion (which was common to both ions). The original part of
this superposition, which was left around, won't happen: no state with
correct energy.

If we have zero excitations in our quantum oscillator, then we can't take
out an excitation. We can separate out the motion, and what we left with is
sd + ds. Remember: we're talking only about the center-of-mass
motion. Normal mode spans the full space of the two ions moving.

Bell-states with atoms: NIST: beryllium, fidelity of 97%; Innsbruck:
calcium, fidelity of 99%, etc.

We all know that there is an infinite number of Bell states, which have
some phase incorporated. Need to play around with the length of the
$\frac{\pi}{2}$ pulse. Must show coherence: interference with each
other. Plus sign makes sense. Not sometimes plus, sometimes minus. We want
to also know relative phase of the superposition.

What we do is develop a method to measure the density matrix. A measurement
yields the z-component of the Bloch vector. Measuring diagonal of the
density matrix is straightforward: enter measured values into this
diagonal. So how, then, are you going to measure these off-diagonal
elements, which determine the phase of this coherence?

How do I, say, measure the projection onto the y-axis? Rotate about x-axis
(apply $\frac{\pi}{2}$-pulse). Enter value here, then prepare same state
again. Do the same with projection onto x-axis.

Now we need to generalize to 2 qubits. Must try all combinations. Need to
do x,y rotations, nothing to first, nothing to second. etc. Analysis, some
linear algebra. Then we come up with the density matrices.

These are actually all measurements. You can even go to more complex
states: largest: 16 zero-qubits + 16 up-qubits. Huge matrix.

W state, etc.

Want to now show some nice things about quantum mechanics: can now prepare
these states, and can now measure individual qubits. Suppose we measure the
red qubit here in the center. Projection onto a self-consistent space.

problems with Hilbert spaces. One more qubit would have increased analysis
time by a factor of 24.

In the last 20 minutes, we've talked only about generation of bell
states. Not yet a quantum state. Original proposal to do controlled-not,
Cirac-Zoller, geometric phase, Malmer-Sorensen gate.

We use a little more complicated mechanism, which is harder to
understand. What we want to do is manipulate our two ions in this
manifold. Put all states. Drive two photon transitions: to move from SD to
DS. Do this by detuning laser from excited state. Equivalent paths:
constructive interference. When you analyze this carefully, you can see
this is a two-qubit universal gate.

Don't need to address ions: automatically implements a gate. Experimentally
easier: higher fidelity, etc.

Analysis of coherence. Applying two single-qubit gates to two ions:
contrast of interference fringes goes up to 1: high-fidelity bell state, so
gate works exceedingly well. One case: gate duration of 51 $\mu
\mathrm{s}$, average fidelity of 99.3(2)%.

Talk about errors. In theory, the fidelity would be sufficient.

Parity + when equal, parity - when unequal, etc. Such an interference
pattern predicted. If not happening, interference fringes have less
contrast. Fidelity decreases as we apply more gates.

Even after 21 equivalent gates, still 8% fidelity.

Scaling of this approach?

Problems:

* Coupling strength between internal and motional states of a N-ion string
  decreases as $\eta \propto \frac{1}{\sqrt{N}$ (reasoning: if you excite
  one ion, a single photon needs to excite the whole ion chain; a single
  photon gets absorbed by the whole ion chain. More difficult for single
  photon to kick entire chain if chain is big), but problem does not scale
  exponentially. From a math point, we are fine (no exponential
  resources).
  
* More vibrational modes increase risk of spurious excitation of unwanted
  nodes.

* Distance between neighbouring ions decreases $\implies$ addressing more
  difficult.

So we need to divide: idea behind using segmented traps.

One problem is complexity. Everything can fail. Suppose one component fails
with error 0.1%, with 10000 components, this will never work.

In some sense the ENIAC looks similar in complexity. What we have done to
make things better was to put a box about it: probability of misalignment
gets worse.

We need to divide the system into smaller pieces: where most (if not all)
of effort of ion-trapping goes at the moment. This is an idea which
actually comes from Leibfried and Wineland, who envisioned many ions
trapped in some structure, and voltages moving ions around. Advantage:
small ion string.

Can show that within 50us we can move ions on the order of a millimeter,
which is huge. Shown on time scales, which are comparable to gate times, so
not too expensive.

Experiment, for instance: sketch of ion trap. What they have done is move
ions between points, and what they have shown is coherence (Ramsey fringes
on a single ion). When they transported, the contrast is approximately the
same. This tells us that the quantum information is not lost during
transport.

Another development is to make the traps easier. People are interested in
using conventional lithography to build easier traps. Recent development:
surface traps. All on one surface; can use microfab techs. Can basically
analyse electrostatics, and ions trapped on such a surface.

That is basically where the experiments are. People are building these
devices and trying to control them. Main challenge. Once we can control
these, we have real scalable quantum processing.

If you want to read about these things, you can look in this review which
is written in a way with hardly any math.

Review on "quantum computing with trapped ions"
http://xxx.lanl.gov/abs/0809.4368

most recent progress: NIST, Boulder
http://www.nist.gov/pml/div688/grp10/quantum-logic-and-coherent-control.cfm

Innsbruck
http://wwww.quantumoptics.at/

University of Maryland
http://www.iontrap.umd.edu/publications/recent_pubs.html

Basic ideas of how this works, physics is fairly clear: quantum mechanics at its best.

<a name='25'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Cryptography
====================
April 24, 2012
--------------

Today we will speak about quantum cryptography. The main question: how to
agree on a secret key? Alice & Bob sitting at distance, can communicate
over insecure channel. Want to agree on shared random key. Often running,
can use private-key crypto, do whatever they want. Getting started, they
want to exchange this private key.

The problem is that Eve is listening on the line. So how do they accomplish
this? Here's the setup: there's a quantum channel which they share. Alice
can send qubits to Bob. They also share a classical channel, except that
they have no control over the classical channel. All they know is that it's
authenticated (public-key signing, perhaps).

Eve also has access to the quantum channel. What we want to do is develop
this protocol: sharing of the random key without loss of confidentiality.

So what happens in classical cryptography? RSA (public key
crypto). Everything we're speaking about today is working under the
assumption that A&B haven't met yet and are only now establishing this
private key.

Why do we need quantum cryptography? Shor's breaks RSA. What we are trying
to achieve is unconditional security -- the only thing you need to assume
in order to guarantee security is that the laws of physics hold (i.e. QM is
an accurate model). Has been implemented using today's cryptography.

What we will talk about today are the principles of quantum crypto.

Qubits used here are polarizations of photons. Polarization as orientation
of light wave as it propagates. In some direction orthogonal to direction
of propagation. Polarization is a qubit. Nice thing: polarizing filter
blocks photons whose polarization is perpendicular to the orientation of
the filter and transmits photons whose polarization is aligned with the
orientation of the filter. It gives us a measurement axis for the photon.

The probability that the photon is transmitted by the second filter is
$\cos^2\theta$. Measurement of the qubit.

What we are saying is that we could write our qubit state $\ket{\psi}
\equiv \alpha\ket{0} + \beta\ket{1}$. Zero vertically-polarized, one
horizontally-polarized. One part of superposition goes through, other part
blocked. Self-consistency. We could also write this in some other basis
$\ket{u}, \ket{u_\perp}$ at some angle $\theta$.

This is really qubits in the same language that we had, except we're
thinking about them as spatially-oriented, just as we thought about
spin. Completely analogous.

So here's what we're planning to do. Two ways to encode a bit of
information. Could either encode in rectilinear (vert/horiz) or in diagonal
(+,-). So when Alice wants to transmit a bit to Bob, if she was using the
rectilinear basis, she'd transmit horizontally/vertically polarized
photons. Bob would then use either a vertical or horizontal filter. Similar
concept with a diagonal polarization.

Remember: all channels are visible to everyone.

Why use both these polarizations? Has to do with uncertainty principle:
these are Fourier transform pairs, so maximally uncertain. You'll recall we
did this in the second or third lecture. We talked about the bit and sign
bases. There's an uncertainty principle between the two. You have a choice
of measurement basis (could be one, could be other, could be a mix) to
determine how much information you get. You cannot get perfect information
about the state of said qubit.

Eve, who doesn't know which basis the information is being sent in, really
cannot figure out both. If Eve tries to measure in the wrong basis, then
she completely destroys the information.

thought regarding decision of which basis to choose: send a bell
state. Confirmation would be on this classical line, just saying "I got &
measured the bell state"

Implementation is actually done without bell states. Very difficult to
implement bell states.

Let's suppose Eve entangled the transmitted qubit with one of her
own. By doing so, she's randomized the state.

The BB84 protocol (that we're going to discuss) was invented in 1984 but was
not proven correct until about a decade ago. People assumed
correctness. Reason: subtle. All other attacks you could think of, but they
don't work. But how do you show that no attack will work?

How do we make use of this scenario? How do we distinguish between Bob and Eve?

Repeat 4N times (if we want to end up with N random bits):

Choose random bit, randomly select basis. Announce choices of
bases. Discard if choices different. Eve can see all of this.

Final result: roughly 2N shared bits. Select N random positions, confirm
that they're the same. Remaining N bits are secret key.

Ensures confidentiality of message. Integrity of key is guaranteed by
communications on classical channel.

Potential corruption of shared key (attack on integrity): Eve just needs to
corrupt one bit. 50% chance of catching this. Refine: more sophisticated
protocol.

Beautiful way of dealing with this, provable correctness.

Single-photon generators imperfect. Occasionally emit two photons. Eve can
intercept one, let the other go, and that breaks the scheme (known vector
of attack).

Polarization over these distances? This is the interesting thing about
photons. If you transmit a photon, there is almost nothing that decoheres
it. Can maintain coherence over long period and long distance. Can transmit
through optical fiber, and it will maintain its polarization for something
like 60 - 70 km.

Issue is why 60-70 km? Because signal gets attenuated. Every so often, you
have to amplify the signal, but of course we don't want to amplify the
signal; we just want to transmit it. Usually involves measurement and
retransmission.

People are trying to build amplifiers that don't do that: small quantum
computers that take the photon, error-correct, and retransmit. But not
implemented yet.

Security of BB84: Since Eve does not know the correct orientation, she
cannot measure the polarization without disturbing it.

Proof of unconditional security based on axioms of QM is difficult and
dates back to about 2000.

Practical considerations:

* imperfect measurements: channel noise causes shared btis to not agree.
  + Figure out noise rate, determine whether acceptable.
  + In this case, Alice and Bob exchange parity bits to correct mismatches.
* Can only guarantee that Eve does not know too many bits out of the
  remaining N.

Randomness distillation. Suppose we are left with 4 bits, and we know the
noise rate is at most a quarter, so Eve knows at most one of these
bits. Want to distill into bits Eve does not know about. Extract key via
XORs. Claim: no matter which bit Eve knows, each bit looks completely
random to Eve.

Choose random hash function to hash these bits. What we can prove is that
Eve has no information regarding the resulting hash. Must deal with these
issues: mismatches and Eve's knowledge.

Turns out that hash function itself doesn't have to be random. Should work
even if hash function is public (and surjective?).

Actual theorem: suppose you pick a hash function H at random, and now let's
say that $N \mapsto M$ (n-bit strings to m-bit strings), and that x is
chosen according to some distribution.

Lemma: left-over hash lemma. If you look at the pair H (specified somehow,
chosen at random), H(x) (m-bit string; H(x) is some string), the claim is
that this distribution is close to the uniform distribution on m-bit
strings, and so you cannot tell the difference between this result and some
random m-bit string.

Has been implemented. Was famous experiment done at a lake near
Geneva. Three locations with optical fiber going between these
locations.

Challenges with atmospheric photon transmission and detection. Background
photons, daylight radiance, night radiance. How to distinguish? Start:
timing pulse -- expect a photon in 1 us, within a window of 1 ns. What can
we control? Narrowness of window of time; part of spectrum which sunlight
that does not use (or least-used), and a very narrow window of frequency,
at that; look at very small solid angle. So we're isolating in terms of
position, momentum, and time. Once you do all of these things you realize
that you can cut down this $10^{13}$ to something very tiny.

So why use photons? Why not use some particle with very strong coherence?
Photons are nice -- very stable, coherent. So what would this other
particle be?

Must take into account GR. Photon essentially does not interfere with
anything else. Remember how hard it is to do cavity QED. To take a photon
and create a gate using said photon is very difficult to do. You put the
photon in a cavity and couple the qubit to the cavity and the cavity to
some other qubit. Outside of these extraordinary efforts, photons are
fairly stable.

Other considerations for photon transmission: efficient lasers (want some
source such that exactly one photon can be transmitted). Already that is
enough to get this off the ground.

Exaamples of 10 km QKD. Commercially available quantum crypto systems.

And then there's this fact. You can prove that these things are secure, but
they aren't really: one possible attack: shine strong laser at Alice; can
figure out internal settings.

Device-independent cryptography. Want to prove quantum crypto scheme secure
based purely on quantum mechanics. What is interesting is that you can show
that in principle, you can create some systems. Theoretically possible to
do.

Quantum key distribution, then use classical private key cryptography,
i.e. schemes secure under quantum cryptography (not known to be broken; no
proximal reason why those would be breakable, given the quantum algorithms
we know).

Two things: course projects. Some of you have sent email giving 2-3
paragraphs describing what you'll be doing and what sources. What would be
good would be if the rest of you could send something hopefully by later
today.

Project presentations: next week Thursday. Will set up in location to be
determined (hopefully here). Will go from 9:30 to 1, perhaps. Go through
all project presentations. Make sure you have a good typed presentation
that fits into ~20 min. With questions, presumably no presentations will go
over 25 min.

Roughly 10 groups. Will try to arrange for pizza -- at some point we'll
break for lunch.

What day will the paper be due? The paper will be due the end of the
following week (end of finals week).

Let's say that there might not be a breakdown in the sense that if you do
particularly well in one, it'll compensate for the other.

Two other issues: 1) there's a question for EECS majors: what should this
course count as? Science requirement? EECS requirement? 50/50? Would be a
useful thing to sort out. Would like to take existing notes for this class
and make them more consistent with what was taught this semester. Two
things: if you've been taking good notes in class, I'd love to have a copy
of those.

<a name='26'></a>

CS 191: Qubits, Quantum Mechanics and Computers
===============================================
Quantum Walks and the Dirac Equation
====================================
April 26, 2012
--------------
Last lecture of the semester. Talk about two things: start with quantum
walks and Dirac equation, and then I'll tell you a little about other
topics in quantum computation you might be interested in. Larger picture,
who, how to pursue.

Before we start, let's review something about classical mechanics. Suppose
we are doing a random walk on a discretized line, so we have grid
points. At each step, we move randomly. How long to reach a distance $n$?

You may recognize this: after k steps, this is given by a binomial
distribution centered at zero, and the standard deviation is about
$\sqrt{k}$: central limit theorem. We can work this out: if you look at the
position after $k$ steps, we have some distribution. We want to know what
the variance of this distribution is, and thus what the standard deviation
is. Turns out that the variance grows as $k$, and so the standard deviation
grows as $\sqrt{k}$. Since each step is a random variable (independent from
all other steps), we can exploit linearity of expectation to find this $k$.

Thus if we want to reach this distance safely, we should expect to walk
roughly $n^2$ steps. That is the penalty for randomness: a factor of $n^2$.

Now assume that instead of dealing with a classical particle and a
classical walk, we're dealing with a quantum particle.

In the classical case, the position is $x$, which is an integer; there is a
coin flip $b$, which is $-1 \lor 1$, and at each step, you flip the coin
and increment $x$ by $b$.

In the quantum case, we again have $x$s and $b$, but now we're keeping
track of everything. The state includes both $x$ and $b$. Whatever the coin
flip says, we move accordingly. And now we must flip the coin. How to flip
the coin, since it's now a quantum bit? Apply the Hadamard to it. That is
our quantum walk on the line.

Now, we could do the same thing, start from the origin, walk for $k$ steps,
and how far do we get? When you do this quantum walk, you end up with most
of the mass at some constant multiplied by $k$: it really walks at constant
rate. Why?

What accounts for the chance at origin being roughly zero in the quantum
case?

We must go back to the classical case and understand this. There are many
ways to return to the origin, but in the quantum case, each way comes with
a phase, and these phases tend to cancel out. When you shoot out to the
ends, you get constructive interference, whereas at the origin, you get
destructive interference.

Qualitatively, the quantum walk behaves very differently from the classical
walk. Remember: in quantum mechanics, you don't have a notion of a
trajectory.

You can also define a continuous version of that by defining an appropriate
Hamiltonian. The Hamiltonian you would need is exactly what you think: it's
the Pauli matrix $\sigma_x$. We'll see how to write this behavior
explicitly in a bit: this will result in the Dirac equation.

So now, let's see how to apply some of these ideas about quantum
walks. What are these useful for? Algorithms. This relates to a quadratic
speedup in the simple case. Tells you if you were using random walks to
design an algorithm, if you switched over to quantum, you'd get quadratic
speedup. You do get quadratic speedup or much speedup for most of these.

What's interesting is a quantum algorithm for formula evaluation: quadratic
speedup for evaluating a boolean expression.

Applications: minmax tree where values are zero and one. And is min, Or is
max.

This finds its use in quantum algorithms and other places. What I want to
talk about today is Dirac's equation, which can be explained nicely with
quantum walks.

This was when he was reconciling quantum mechanics with special relativity,
which also led him to the role of spin and the relativistic origins of
spin. Also led him to his discovery of antimatter. This was really quite a
remarkable event in physics, and what was interesting was that also, in all
this was just how much courage Dirac had in terms of looking at this
problem, finding this very simple equation, and having the courage to stand
by something so new that had so many major consequences.

So let's go back: we have a particle whose energy is classically
$\frac{p^2}{2m}$. Quantumly, this is $\frac{\hat{p}^2}{2m}$, where $\hat{p}
\equiv \frac{\hbar}{i}\nabla$. So now, let's try to understand
relativistically that the energy is given by the Klein-Gordon equation
(Einstein's theory of relativity, really, which arises from invariances of
moving frames), which says that $E^2 = p^2c^2 + m^2c^4$ (where $c$ is speed
of light), and $p^2c^2$ is the kinetic form.

If you try to figure out what this is saying, when a particle has speed
much less than that of the speed of light, you can pull out $mc^2$, and you
get $mc^2\sqrt{1 + \frac{p^2}{m^2c^2}}$. Since this is small, you can
approximate this as $mc^2(1 + \frac{p}{2mc^2})$ (first-order Taylor
expansion with respect to p). Expanding this, we get $mc^2$ (energy
associated with rest mass) added to $\frac{p^2}{2m}$. And that's exactly
what you want: that is the total energy.

So all is fine and well, and now, what Dirac was trying to do was figure
out what the corresponding quantum equation is: $H^2 = \hat{p^2}c^2 + m^2
c^4 I$ (where $I$ is the identity). This is the square of the
Hamiltonian. How do you compute the Hamiltonian itself? This is exactly
what Dirac was trying to do: he was trying to compute the square root of
this operator. Youc an try to compute square roots, use Taylor series, it
blows up, and it doesn't really look like anything. And then he had this
insight.

Let's use units where $c=1$. What we're trying to do is compute $H =
\sqrt{p^2 + m^2 I}$, where both of these are operators. Here was the flash
of insight: what he realized was if you wrote the Hamiltonian by doubling
the dimension as $\begin{pmatrix}\hat{p} & mI \\ mI &
-\hat{p}\end{pmatrix}$. So what happens when you square this? We get
$\begin{pmatrix}\hat{p}^2 + mI & 0 \\ 0 & \hat{p}^2 + mI \end{pmatrix}$.

Has this feel about it that in trying to solve this especially difficult
problem, and by stepping outside of what seem to be the rules of the game,
it suddenly becomes very simple. And then instead of saying this is
illegal, perhaps these actually are the correct rules of the game.

And so what Dirac said was that there's an extra degree of freedom: it's a
qubit -- spin. So now we can try to understand what this tells us about how
the particle moves relativistically. If we write that out, we want to solve
$i\pderiv{\Psi}{t} = H \Psi$. Let's do case 1: $m = 0$.

So what's our state space? There's the position of the particle, and then
there's spin. The Hamiltonian is going to act on the whole thing. What will
this look like? In general, it's acting on the two spaces together. If you
were to write out the state vector, it consists of the component with spin
$b=0$ and the component with spin $b=1$.

With the massless particle, $\pderiv{\psi}{t} = -\nabla\psi$, so in the
one-dimensional case, $\psi$ is moving right with the speed of light. So
there are two solutions, depending on your spin qubit: in one case, you're
moving right at the speed of light, and in the other case, you're moving
left with the speed of light.

So what happens in general? You have this term that corresponds to motion
left or right at the speed of light, and then you have the term that
corresponds to the mass. The greater the mass, the more often you flip the
coin. The presence of the mass term corresponds to a new direction after
each coin flip, so to speak. Recall that we moved $ak$ for some $a$. With
no mass, $a$ is $c$. As we increase the mass, $a$ decreases.

There's another thing you might think about: in the classical case, after k
steps, you move $\sqrt{k}$. You can move one step per unit time right or
left. But of course we want to let that unit tend to zero, so $k$ tends to
infinity.

In fact, what Dirac did was work out this problem, and he worked out the
statistics of this walk. He didn't call it a quantum walk, but that's what
he implicitly did.

So that's it regarding quantum walks and the Dirac equation. I'll now spend
the next ten minutes talking how to further pursue quantum computing. If
you have specific questions, feel free to ask.

There are many different areas here in quantum computing, which is
partitioned into three primary flavors of research: theory work -- consists
of quantum algorithms (design), complexity theory (QBP = P?), information,
crypto. The boundaries will vary depending on your source.

Quantum information theory: quantum analog of classical information theory:
how much classical information can I transmit in each qubit? What's the
value of quantum information? And the second part: error correction and
fault-tolerance. If you want to build a quantum computer, one thing you
have to worry about is decoherence. Previously people thought that quantum
states were not protectable: they degrade over time as the environment
decoheres them. This is a way of putting this quantum information inside a
sort of error-correcting envelope for protection. Even after being subject
to errors, we can still recover the original message (a quantum state).

Physically, you think about these errors as heating of the system (increase
of entropy). What do you do? Take fresh qubits all initialized to zeros
(supercooled), and do heat exchange. Take all the heat (in the form of
errors), isolate it, and push it into these cold qubits. Now these errors
are sitting inside these new qubits, which we can then discard --
refrigeration. If you do that, that's called fault-tolerance.

Cryptography we know about. There's one subject I haven't talked about:
post-quantum cryptography. Quantum algorithms break most of modern crypto:
RSA, Diffie-Hellman, you name it. What we'd like to do is restore
public-key cryptography, and eventually use private-key cryptography. You
could use quantum cryptography, but even though there are existing systems,
they're very difficult to use.

There's a different way out: how about designing public-key cryptosystems
which quantum computers cannot break?  Very active field of research. If
you think about it, this may be the biggest practical impact of quantum
computation in the very near future (next few years). Would be very
interesting if that happens; it's not the quantum computers that would have
the impact, but rather the threat of quantum computers.

Two other fields are simulating quantum systems: the starting point for
quantum computation, to simulate this, we normally would need an
exponential amount of work to simulate. So how would you simulate quantum
systems efficiently on a quantucm computer? There are interesting results
here: how would you, for instance, run the quantum metropolis algorithm?
The second question: how to simulate on a classical computer. Here, the
question is not how to simulate general systems, but rather, could it be
that natural quantum systems are somehow much simpler and can be simulated
very efficiently, even if they are highly-entangled? There is a renaissance
of information in this field.

Special systems can be solved explicitly (closed-form). Those can be
simulated on a classical computer. There are many others that can't be
solved explicitly, but they have certain properties that we can take
advantage of.

And finally, there is a lot of work on experimental quantum
computing. Various techniques.

In terms of resources: Haffner teaches a course on quantum computing from a
more experimental viewpoint. In terms of the physics department, there's
Haffner, Clark (superconducting qubits), Stamper-Kurn (Bose-Einstein
condensates, optical systems), Szdiki, Crommie. In the chemistry
department, there's Waley, who might teach this course next year. There's
also a colleague in computer science: Kubiatowicz -- quantum architecture.

How to put together? Let's say that three years from now, ion traps work
and scale to a few hundred qubits. Now how would you put them together to
do interesting computations? What are the architectural tradeoffs: should
you keep qubits close or teleport, how to manage ECC, etc.

Few places other than Berkeley; Waterloo (IQC, perimeter institute),
Caltech, MIT, U. Maryland -- growing group, CQT in Singapore (which
actually offers a degree in QC). Number of resources. And then there are
groups in Europe which are very strong: Munich, Germany, Paris. There are
lots of resources internationally, but also there are plenty of
opportunities for summer schools if interested or graduate work in the
area.

If you want any more information, you can email or stop by.
